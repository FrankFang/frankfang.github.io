<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>方应杭的个人网站 on 方应杭的个人网站</title>
    <link>http://fangyinghang.com/</link>
    <description>Recent content in 方应杭的个人网站 on 方应杭的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 08 Nov 2018 04:04:02 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>我的课程</title>
      <link>http://fangyinghang.com/my/courses/</link>
      <pubDate>Thu, 08 Nov 2018 04:04:02 +0800</pubDate>
      
      <guid>http://fangyinghang.com/my/courses/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/63308031-98f4-4907-ade4-c22d4aa82f27&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;React 入门（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/6f105ef5-8969-4863-82e7-beb162ddc5b3&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;TypeScript 入门（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/9ff75915-a19f-451d-b3a5-85feed5a6bc1&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;SCSS 入门（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/6d63da67-6eea-4711-aeb4-0c3a949341dc&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;自制 Vue UI 框架（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/24f54465-854f-4de7-9808-72a0bf5b3181&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS 深入浅出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/12a78a03-35f9-42ea-9b37-540540460f6e&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ES6 深入浅出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/003b1951-22af-4821-ad80-d2880c0074eb&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;CSS 深入浅出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/ec3a5e28-02da-47d6-9226-927db23e82a2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;前端零基础入门&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>经历</title>
      <link>http://fangyinghang.com/my/resume/</link>
      <pubDate>Thu, 08 Nov 2018 04:04:02 +0800</pubDate>
      
      <guid>http://fangyinghang.com/my/resume/</guid>
      <description>&lt;p&gt;毕业于华中科技大学软件工程专业，先后在腾讯、阿里巴巴、彩程担任前端工程师。
现在在 &lt;a href=&#34;https://jirengu.com&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;饥人谷&lt;/a&gt; 讲课、开发、写作。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;技术栈&#34;&gt;技术栈&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Web 前端开发技术（CSS、JavaScript、TypeScript、Vue、React、Angular 等）&lt;/li&gt;
&lt;li&gt;Web 后端开发技术（Ruby on Rails、Node.js 等）&lt;/li&gt;
&lt;li&gt;正在学习 Kotlin、Swift&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;工具箱&#34;&gt;工具箱&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;编辑器喜欢用 vim、WebStorm、RubyMine，&lt;a href=&#34;https://jscode.me/t/topic/851&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;vim 配置&lt;/a&gt; 还挺简洁的。&lt;/li&gt;
&lt;li&gt;在 iTerm2.app + zshell 里运行命令行&lt;/li&gt;
&lt;li&gt;使用 Paste.app 管理剪切板&lt;/li&gt;
&lt;li&gt;使用 xScope + Sip + Sketch 切图&lt;/li&gt;
&lt;li&gt;使用印象笔记管理知识&lt;/li&gt;
&lt;li&gt;使用 The Hit List.app + Tower.im 管理工作任务&lt;/li&gt;
&lt;li&gt;讲课时非常喜欢用 &lt;a href=&#34;https://detail.tmall.com/item.htm?id=17866298588&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Wacom 数位板&lt;/a&gt; 演示思路&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>微信订阅</title>
      <link>http://fangyinghang.com/wechat-subscribe/</link>
      <pubDate>Thu, 08 Nov 2018 03:43:41 +0800</pubDate>
      
      <guid>http://fangyinghang.com/wechat-subscribe/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/me/qrcode.jpg&#34; alt=&#34;扫码关注&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>联系方式</title>
      <link>http://fangyinghang.com/contacts/</link>
      <pubDate>Thu, 08 Nov 2018 03:43:41 +0800</pubDate>
      
      <guid>http://fangyinghang.com/contacts/</guid>
      <description>&lt;p&gt;邮箱：fangyinghang # foxmail.com&lt;/p&gt;

&lt;p&gt;知乎：&lt;a href=&#34;https://www.zhihu.com/people/zhihusucks/answers/by_votes&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;zhihusucks&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jQuery 都过时了，那我还学它干嘛？</title>
      <link>http://fangyinghang.com/2018/why-still-jquery/</link>
      <pubDate>Mon, 15 Oct 2018 16:22:04 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2018/why-still-jquery/</guid>
      <description>

&lt;p&gt;今天饥人谷的新生问我&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;请问现在我还需要学习 jQuery 吗？听你在知乎说 jQuery 已经过时了，是不是就不用学了？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;短答案&#34;&gt;短答案&lt;/h2&gt;

&lt;p&gt;jQuery 还是可以学一学的，学了之后对写代码和封装库很有帮助。&lt;/p&gt;

&lt;p&gt;现在的「新人」依然可以学习 jQuery 的思想，因为以「新人」的水平，直接理解 Vue / React 的思想难度较大，jQuery 是一个很不错的中间过渡，因为 jQuery 也蕴含了非常多的编程套路。&lt;/p&gt;

&lt;p&gt;但是如果你不想学，就不学吧。直接去学 Vue / React 会难一点，但也能学会。&lt;/p&gt;

&lt;h2 id=&#34;长答案&#34;&gt;长答案：&lt;/h2&gt;

&lt;p&gt;jQuery 当然过时了。&lt;/p&gt;

&lt;p&gt;距离我上次在项目中使用 jQuery，可能已经快两年时间了（除去上课时演示功能时用 jQuery）。回想我学习 jQuery 的过程，还挺神奇的。&lt;/p&gt;

&lt;p&gt;当年我在大学的技术小组里做 C# 网站开发，需要用到 jQuery 特效，组里的一名小伙伴会用一点 jQuery，很快就用 .animate 做出了让我啧啧称奇的特效。我觉得 jQuery 好神奇啊，虽然我当时连 JS 都不会。&lt;/p&gt;

&lt;p&gt;于是我立马买了一本《锋利的 jQuery》，硬看。&lt;/p&gt;

&lt;p&gt;什么叫「硬看」呢？因为我不会 JS，而且我并没有照着书上敲代码，仅仅使用眼睛「看 jQuery 代码」。神奇的是——我居然很快看懂了几乎整本书。以至于那位会用 jQuery 的小伙伴遇到 bug 问我时我能直接给出解答，看起来他并没有看《锋利的 jQuery》这本书（笑）。&lt;/p&gt;

&lt;p&gt;到了 2018 年，几乎已经没有新项目会使用 jQuery 来开发了；即使有，也是一件不值得拿出来炫耀的事情。那为什么我还是建议学习 jQuery 呢？&lt;/p&gt;

&lt;p&gt;原因如下。&lt;/p&gt;

&lt;h2 id=&#34;jquery-教你如何设计-api&#34;&gt;jQuery 教你如何设计 API&lt;/h2&gt;

&lt;p&gt;上文说到我一个不会 JS 的人居然能看懂 jQuery 的书，其实这不是因为我厉害，而是因为 jQuery 的 API 设计得太人性化了！&lt;/p&gt;

&lt;p&gt;举几个例子给大家看看：&lt;/p&gt;

&lt;p&gt;第一个是 jQuery 对事件监听的简化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 那时，如果不用 jQuery，监听事件（兼容 IE 6）你要这么写
if (button.addEventListener)  
  button.addEventListener(&#39;click&#39;,fn);
else if (button.attachEvent) { 
  button.attachEvent(&#39;onclick&#39;, fn);
}else {
  button.onclick = fn;
}

// 但是如果你用 jQuery，你只需要这么写
$(button).on(&#39;click&#39;, fn)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个是 jQuery 对元素选择的简化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 如果你想获取 .nav &amp;gt; .navItem 对应的所有元素，用 jQuery 是这样写的
$(&#39;.nav &amp;gt; .navItem&#39;)

// 在 IE 6 上，你得这么写
var navItems = document.getElementsByClassName(&#39;navItem&#39;)
var result = []
for(var i = 0; i &amp;lt; navItems.length; i++){
  if(navItems[i].parentNode.className.match(/\bnav\b/){
    result.push(navItems[i])
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有没有发现 jQuery 的代码一读就读懂了？可读性非常强！&lt;/p&gt;

&lt;p&gt;当时我作为一个新人，每每看到 jQuery 那优雅的 API，都禁不住去思考 jQuery 到底是怎么实现的，我自己能不能实现出来（但我并不推荐看 jQuery 源码）。本着这样的想法，我学会了很多编程技巧。&lt;/p&gt;

&lt;p&gt;为什么有些人代码水平老是提不高了，就是因为不会造轮子，不会设计优雅的 API，更不会实现优雅的 API，只会调用其他库或框架提供的功能（中枪的举手）。&lt;/p&gt;

&lt;p&gt;而 jQuery 则提供了一个简单而又经典的范例供大家学习。&lt;/p&gt;

&lt;p&gt;不信的话我们就来看看 jQuery 用到了哪些所谓的设计模式（其实就是编程套路）吧。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;发布订阅模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var eventHub = $({})
eventHub.on(&#39;xxx&#39;, function(){ console.log(&#39;收到&#39;) })
eventHub.trigger(&#39;xxx&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用原型继承实现插件系统&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.fn.modal = function(){ ... }
$(&#39;#div1&#39;).modal()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vue 2 的插件也是类似的思路哦&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事件委托&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;).on(&#39;click&#39;, &#39;span&#39;, function(){...})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说实话，你在 2018 年找前端让他写一个事件委托，我保证 90% 写出来的代码都是有「明显」bug 的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;链式调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;).text(&#39;hi&#39;).addClass(&#39;red&#39;).animate({left: 100})
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数重载（伪）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(fn)
$(&#39;div&#39;)
$(div)
$($(div))
$(&#39;span&#39;, &#39;#scope1&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会发现 $ 这个函数的参数可以是函数、字符串、元素和 jQuery 对象，甚至还能接受多个参数，这种重载是怎么做到的？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;命名空间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 你的插件在一个 button 上绑定了很多事件
$button.on(&#39;click.plugin&#39;, function(){...})
$button.on(&#39;mouseenter.plugin&#39;, function(){...})
// 然后你想在某个时刻移除以上所有事件
$button.off(&#39;.plugin&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不用 jQuery 就很麻烦了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;高阶函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fn2 = $.proxy(fn1, asThis, param1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$.proxy 接受一个函数，返回一个新的函数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其他就不一一列举了。&lt;/p&gt;

&lt;h2 id=&#34;jquery-的-api-风格依然在流行&#34;&gt;jQuery 的 API 风格依然在流行&lt;/h2&gt;

&lt;p&gt;我们把 jQuery 和 Axios 做一下对比：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajax({url:&#39;/api&#39;, method:&#39;get&#39;})
$.get(&#39;/api&#39;).then(fn1,fn2)

axios({ url: &#39;/api&#39;, method: &#39;get&#39;})
axios.get(&#39;/api&#39;).then(fn1, fn2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么 2018 年流行的 axios 跟 jQuery.ajax 这么相像呢？&lt;/p&gt;

&lt;p&gt;因为 jQuery 的 API 实在太好用了！搞得新库根本没法超越它，没有办法设计出更简洁的 API 了。毕竟 jQuery 也是在前端界流行近十年。&lt;/p&gt;

&lt;p&gt;所以你学了 jQuery 很容易过渡其他类似的新库。&lt;/p&gt;

&lt;h2 id=&#34;jquery-也能做-mvc&#34;&gt;jQuery 也能做 MVC&lt;/h2&gt;

&lt;p&gt;很多人以为前端框架是从 Vue、React 和 Angular 才开始的，其实 jQuery 时代早就有基于 jQuery 的 MV* 库了，比如著名的 Backbone.js 和 Marionette.js。&lt;/p&gt;

&lt;p&gt;看看下面的 Backbone 应用代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var TodoView = Backbone.View.extend({
    tagName:  &#39;div&#39;,
    template: _.template($(&#39;#item-template&#39;).html()),
    events: {
        &#39;click .toggle&#39;: &#39;xxx&#39;,
    },
    initialize: function () {
        this.listenTo(this.model, &#39;change&#39;, this.render);
    },
    render: function () {
        if (this.model.changed.id !== undefined) {return; }
        this.$el.html(this.template(this.model.toJSON()));
        return this;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AngularJS、Vue 1.x、Vue 2.x 其实都是顺着 Backbone MVC 的思路慢慢优化、改造得来的，如果你提前了解 Backbone 作为知识铺垫，那么理解 Vue 是非常容易的。如果面试官问你 MVC 和 MVVM 的区别，你也是很容易就可以答出来的。&lt;/p&gt;

&lt;p&gt;最后就引用我之前的一个回答作为结尾来说明学习 jQuery 意义：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/20521802/answer/290354219&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;完全理解jQuery源代码，在前端行业算什么水平？&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;说明你&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;精通正则表达式&lt;/li&gt;
&lt;li&gt;了解闭包&lt;/li&gt;
&lt;li&gt;了解原型链&lt;/li&gt;
&lt;li&gt;精通 DOM API&lt;/li&gt;
&lt;li&gt;了解各种设计模式（事件、Promise、伪重载、装饰器模式等）&lt;/li&gt;
&lt;li&gt;精通 DOM 事件&lt;/li&gt;
&lt;li&gt;了解旧浏览器的各种特性（bug）&lt;/li&gt;
&lt;li&gt;了解模块化&lt;/li&gt;
&lt;li&gt;了解浏览器渲染原理&lt;/li&gt;
&lt;li&gt;精通 AJAX&lt;/li&gt;
&lt;li&gt;了解 HTTP 请求&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以秒杀中国 80% 的前端&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>我写了一个基于 Vue 的 UI 框架——轱辘 UI</title>
      <link>http://fangyinghang.com/2018/gulu-ui/</link>
      <pubDate>Fri, 03 Aug 2018 16:32:18 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2018/gulu-ui/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://frankfang.github.io/gulu/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官方文档&lt;/a&gt; | &lt;a href=&#34;https://github.com/FrankFang/gulu&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;源码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;轱辘 UI 是一个不太一样的 UI 框架。&lt;/p&gt;

&lt;p&gt;本 UI 框架是一个「面向源码阅读者」的框架。如果对你有帮助，请不要吝惜你的 star。&lt;/p&gt;

&lt;p&gt;也就是说，我制作这个框架的目的就是让前端新人学习轮子的制作思路。所有代码都追求可读性。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你可以通过查看逐个 commit 来学习本框架的制作思路&lt;/li&gt;
&lt;li&gt;也可以通过我&lt;a href=&#34;https://xiedaimala.com/courses/6d63da67-6eea-4711-aeb4-0c3a949341dc&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;录制的视频&lt;/a&gt;来学习
（抱歉，由于制作非常耗时，所以视频是收费的。不过项目搭建过程的录屏是&lt;strong&gt;免费&lt;/strong&gt;的，这几节视频能帮你快速从零开始本项目。）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你想从第一个commit 开始看，请点击&lt;a href=&#34;https://github.com/FrankFang/gulu/commits/master?after=36fbd6867d0a223184ad67e3d2bc3569e88847e0+104&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果你对代码有疑问，欢迎&lt;a href=&#34;https://github.com/frankfang/gulu/issues&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;提issue&lt;/a&gt;，我会回答你的疑问。也可以在本文末尾加群咨询。&lt;/p&gt;

&lt;p&gt;本 UI 框架是基于 Vue 2 实现的。&lt;/p&gt;

&lt;p&gt;注意：本 UI 框架的代码尚未完全完工（目前代码大概完成 50%），请不要在生产环境中使用本 UI 框架。&lt;/p&gt;

&lt;h2 id=&#34;你能学到什么&#34;&gt;你能学到什么&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;单元测试、覆盖率、持续集成等工程概念&lt;/li&gt;
&lt;li&gt;重构、TDD/BDD、设计模式、单向数据流等技术概念&lt;/li&gt;
&lt;li&gt;Vue 的几乎所有功能，并且是深入理解这些功能，而不是肤浅理解&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;有哪些轮子&#34;&gt;有哪些轮子&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;简单轮子：按钮、输入框、网格、布局、Toast、Tabs、Popover、手风琴（代码已完成）&lt;/li&gt;
&lt;li&gt;进阶轮子：级联选择、无缝轮播、响应式导航条、分页、表单验证、Table、图片上传、Sticky、Tree、Suggestion、Datepicker（代码未完成）&lt;/li&gt;
&lt;li&gt;其他：路由、状态管理（代码未完成）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：这只是目前的计划，具体要完成的轮子可能与上面有出入。&lt;/p&gt;

&lt;h2 id=&#34;项目特点&#34;&gt;项目特点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;使用 Travis CI 进行持续集成&lt;/li&gt;
&lt;li&gt;有丰富的单元测试，项目完成时，期望测试覆盖率超过 90%&lt;/li&gt;
&lt;li&gt;自说明的代码，即使没有注释，你也能看懂&lt;/li&gt;
&lt;li&gt;初期我使用 parcel 构建方便新人上手，后期改为 Vue Cli 3 以实现更多功能&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;我几年前曾经发表过《&lt;a href=&#34;https://juejin.im/post/58ef6004ac502e006c16f2d6&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;笨办法学前端&lt;/a&gt;》一文，
当时我觉得开源社区里虽然有很多不错的库，但是这些库都是以实用为主，其源码并不适合&lt;strong&gt;新人&lt;/strong&gt;阅读。&lt;/p&gt;

&lt;p&gt;于是我业余时间用原生 JS 造了几个轮子放在 GitHub，没想到居然有几百人关注，还希望我能发布更详细的教程。&lt;/p&gt;

&lt;p&gt;但是我当时并没有时间来做更详细的教程。&lt;/p&gt;

&lt;p&gt;现在我终于……还是很忙，不过我决定用每周六和周日来录制「造轮子」的视频。&lt;/p&gt;

&lt;p&gt;这一次为了顺应前端的潮流，我直接采用 Vue 2 来造轮子。如果你正在学习 Vue 2，那么轱辘 UI 的源码会非常适合你阅读。&lt;/p&gt;

&lt;h2 id=&#34;视觉稿&#34;&gt;视觉稿&lt;/h2&gt;

&lt;p&gt;本 UI 框架借鉴了一些成熟 UI 框架（如 Framework7、Element UI 和 Ant Design）的外观，简化之后我自己制作了一个&lt;a href=&#34;https://www.yuque.com/u29422/gulu/artboards/22283&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;视觉稿&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果你发现视觉稿有什么不足的地方，可以直接在上面留言，我也会看到。&lt;/p&gt;

&lt;h2 id=&#34;为什么叫轱辘ui&#34;&gt;为什么叫轱辘UI&lt;/h2&gt;

&lt;p&gt;因为轱辘就是「轮子」的意思，这个项目几乎就是在造轮子。&lt;/p&gt;

&lt;h2 id=&#34;微信交流群&#34;&gt;微信交流群&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qr.jirengu.com/api/taskUrl?tid=8&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;点击查看二维码&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我用了两个月的时间才理解 let</title>
      <link>http://fangyinghang.com/2017/let-in-js/</link>
      <pubDate>Thu, 27 Jul 2017 13:39:30 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2017/let-in-js/</guid>
      <description>

&lt;p&gt;当然不是说用完整的两个月时间来理解 let，而是零零碎碎地理解，同时我还要想着怎么写出一篇文章把这个事情说清楚。&lt;/p&gt;

&lt;p&gt;在 let 刚出来的时候，我就「以为」我理解了 let。然鹅在过去的两个月里，我对 let 的理解发生了一波三折的变化。&lt;/p&gt;

&lt;p&gt;我写这篇文章，是希望我的学习过程，能对你自学有帮助。&lt;/p&gt;

&lt;h2 id=&#34;初识-let&#34;&gt;初识 let&lt;/h2&gt;

&lt;p&gt;跟很多人一样，我第一次了解 let 的特性是从 MDN 的文档：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我得到的信息有这么几条：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;let 声明的变量的作用域是块级的；&lt;/li&gt;
&lt;li&gt;let 不能重复声明已存在的变量；&lt;/li&gt;
&lt;li&gt;let 有暂时死区，不会被提升。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大部分人应该都是这么认为的，我也是这么理解的。&lt;/p&gt;

&lt;p&gt;这个理解「没有问题」，但是不够「全面和深刻」。&lt;/p&gt;

&lt;h2 id=&#34;第一次质疑&#34;&gt;第一次质疑&lt;/h2&gt;

&lt;p&gt;我第一次质疑我的理解是在遇到 for 循环的时候，代码如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代码段1
var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li
for( var i=0; i&amp;lt;liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家都知道依次点击 li 会打印出 5 个 5。如果把 var i 改成 let i，就会分别打印出 0、1、2、3、4：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代码段2
var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li
for( let i=0; i&amp;lt;liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，用我之前的知识来理解这个代码是不能自圆其说的。因为代码中依然只声明了一个 i，在 for 循环结束后，i 的值还是会变成 5 才对。&lt;/p&gt;

&lt;p&gt;这说明我的理解有误。&lt;/p&gt;

&lt;p&gt;于是我去看 MDN 的例子，发现鸡贼的 MDN 巧妙地避开了这个问题，它的例子是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;你看 MDN 的例子，在每次循环的时候用 let j 保留的 i 的值，所以在 i 变化的时候，j 并不会变化。而console.log 的是 j，所以不会出现 5 个 5。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么 MDN 要故意声明一个 j 呢，为什么不直接用 i 呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我猜测 MDN 为了简化知识，隐瞒了什么。&lt;/p&gt;

&lt;p&gt;于是我去看了看 ES 文档，其中的 &lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement-runtime-semantics-labelledevaluation&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;13.7.4.7 章节&lt;/a&gt;
清楚地说明了个中缘由，但是由于说得太清楚了，很多人都看不下去，不信你可以试试。&lt;/p&gt;

&lt;p&gt;我说一下我的理解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;for( let i = 0; i&amp;lt; 5; i++)&lt;/code&gt; 这句话的圆括号之间，有一个隐藏的作用域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for( let i = 0; i&amp;lt; 5; i++) { 循环体 }&lt;/code&gt; 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。&lt;/li&gt;
&lt;li&gt;其他细节就不说了，太细碎了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说上面的代码段2可以近似近似近似地理解为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代码段3
var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li
for( let i=0; i&amp;lt;liList.length; i++){
  let i = 隐藏作用域中的i // 看这里看这里看这里
  liList[i].onclick = function(){
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那样的话，5 次循环，就会有 5 个不同的 i，console.log 出来的 i 当然也是不同的值。&lt;/p&gt;

&lt;p&gt;再加上隐藏作用域里的 i，一共有 6 个 i。&lt;/p&gt;

&lt;p&gt;这就是 MDN 加那句 &lt;code&gt;let j = i&lt;/code&gt; 的原因：方便新人理解。&lt;/p&gt;

&lt;p&gt;总得来说就是 let/const 在与 for 一起用时，会有一个 perIterationBindings 的概念（一种语法糖）。&lt;/p&gt;

&lt;p&gt;从此之后，我就开始怀疑我对 let 的所有理解了。&lt;/p&gt;

&lt;h2 id=&#34;第二次质疑&#34;&gt;第二次质疑&lt;/h2&gt;

&lt;p&gt;我在 StackOverflow 上闲逛的时候，无意中发现了一个是关于「let 到底有没有提升」的问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Are variables declared with let or const not hoisted in ES6?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中一个高票回答认为 JS 中所有的声明（var/let/const/function/class），都存在提升，理由是如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = &amp;quot;global&amp;quot;;
// function scope:
(function() {
    x; // not &amp;quot;global&amp;quot;

    var/let/… x;
}());
// block scope (not for `var`s):
{
    x; // not &amp;quot;global&amp;quot;

    let/const/… x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我觉得他说得挺有道理的。于是我又去 MDN 和 ECMAScript 翻了翻，发现两处疑点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MDN 关于 let 是否存在提升的章节，被编辑了两次，第一次说存在提升，第二次说不存在提升（参考 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let%24compare?locale=en-US&amp;amp;to=1242757&amp;amp;from=1242229&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;2017 年 3 月 10 号的变更记录&lt;/a&gt;）。也就是说 MDN 的维护者都在这个问题上产生过分歧，更何况我们了。&lt;/li&gt;
&lt;li&gt;ES 文档里出现了「var/let hoisting」字样。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;鉴于此，我认为应该尊重 ES 文档，认为 let 确实存在提升。只不过由于暂时死区的限制，你不能在 let x 之前使用 let（详见我的那篇 let 声明会提升（hoist）吗？）。&lt;/p&gt;

&lt;h2 id=&#34;故事并没有结束&#34;&gt;故事并没有结束&lt;/h2&gt;

&lt;p&gt;当一个疑问一直存在你脑中时，你会在潜意识中不停地对它进行消化和思考。&lt;/p&gt;

&lt;p&gt;上面说到我认为 let 存在提升的主要原因是 ES 文档中出现了「var/let hoisting」字样。&lt;/p&gt;

&lt;p&gt;但是我在咨询 TC39 的成员 &lt;a href=&#34;https://twitter.com/rwaldron&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Rick Waldron&lt;/a&gt; 时，他是这么说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You&amp;rsquo;re misunderstanding the intention of that (non-normative) Note. let and const do not hoist as var and function decls do.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而且还细心地专门写了一个 &lt;a href=&#34;https://gist.github.com/rwaldron/ca35924d59ddc60a6aa165e1e4a3acda&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;gist&lt;/a&gt; 来详细解释（twitter 有 140 字限制）。&lt;/p&gt;

&lt;p&gt;既然 TC39 的 representative 都说了 let hoisting 不是一个正式词汇，那我就应该重新思考一下什么是「提升」了。&lt;/p&gt;

&lt;p&gt;于是就有了这篇文章，我想要说一下我对「提升」的理解。你看完之后，就知道 let 到底有没有「提升」。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先明确一点：提升不是一个技术名词。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」&lt;/p&gt;

&lt;p&gt;有的地方把创建说成是声明（declare），为了将这个概念与变量声明区别开，我故意不使用声明这个字眼。&lt;/p&gt;

&lt;p&gt;有的地方把初始化叫做绑定（binding），但我感觉这个词不如初始化形象。&lt;/p&gt;

&lt;h2 id=&#34;创建-初始化和赋值&#34;&gt;创建、初始化和赋值&lt;/h2&gt;

&lt;h3 id=&#34;我们来看看-var-声明的-创建-初始化和赋值-过程&#34;&gt;我们来看看 var 声明的「创建、初始化和赋值」过程&lt;/h3&gt;

&lt;p&gt;假设有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fn(){
  var x = 1
  var y = 2
}
fn()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在执行 fn 时，会有以下过程（不完全）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;进入 fn，为 fn 创建一个环境。&lt;/li&gt;
&lt;li&gt;找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。&lt;/li&gt;
&lt;li&gt;将这些变量「初始化」为 undefined。&lt;/li&gt;
&lt;li&gt;开始执行代码&lt;/li&gt;
&lt;li&gt;x = 1 将 x 变量「赋值」为 1&lt;/li&gt;
&lt;li&gt;y = 2 将 y 变量「赋值」为 2&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。&lt;/p&gt;

&lt;p&gt;这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。&lt;/p&gt;

&lt;h3 id=&#34;接下来来看-function-声明的-创建-初始化和赋值-过程&#34;&gt;接下来来看 function 声明的「创建、初始化和赋值」过程&lt;/h3&gt;

&lt;p&gt;假设代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn2()

function fn2(){
  console.log(2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JS 引擎会有以下过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找到所有用 function 声明的变量，在环境中「创建」这些变量。&lt;/li&gt;
&lt;li&gt;将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。&lt;/li&gt;
&lt;li&gt;开始执行代码 fn2()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」。&lt;/p&gt;

&lt;h3 id=&#34;接下来看-let-声明的-创建-初始化和赋值-过程&#34;&gt;接下来看 let 声明的「创建、初始化和赋值」过程&lt;/h3&gt;

&lt;p&gt;假设代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  let x = 1
  x = 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只看 {} 里面的过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找到所有用 let 声明的变量，在环境中「创建」这些变量&lt;/li&gt;
&lt;li&gt;开始执行代码（注意现在还没有初始化）&lt;/li&gt;
&lt;li&gt;执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）&lt;/li&gt;
&lt;li&gt;执行 x = 2，对 x 进行「赋值」&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就解释了为什么在 let x 之前使用 x 会报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = &#39;global&#39;
{
  console.log(x) // Uncaught ReferenceError: x is not defined
  let x = 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因有两个&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;console.log(x) 中的 x 指的是下面的 x，而不是全局的 x&lt;/li&gt;
&lt;li&gt;执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看到这里，你应该明白了 let 到底有没有提升：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;let 的「创建」过程被提升了，但是初始化没有提升。&lt;/li&gt;
&lt;li&gt;var 的「创建」和「初始化」都被提升了。&lt;/li&gt;
&lt;li&gt;function 的「创建」「初始化」和「赋值」都被提升了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后看 const，其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程。&lt;/p&gt;

&lt;p&gt;这四种声明，用下图就可以快速理解：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所谓暂时死区，就是&lt;strong&gt;不能在初始化之前，使用变量&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;完了吗&#34;&gt;完了吗？&lt;/h2&gt;

&lt;p&gt;故事依然没有结束，这周我在知乎上&lt;a href=&#34;https://www.zhihu.com/question/62966713&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;问了一个问题&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如何理解 let x = x 报错之后，再次 let x 依然会报错？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个问题是饥人谷的学生问我的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个问题说明：如果 let x 的初始化过程失败了，那么&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;x 变量就将永远处于 created 状态。&lt;/li&gt;
&lt;li&gt;你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。&lt;/li&gt;
&lt;li&gt;由于 x 无法被初始化，所以 x 永远处在暂时死区（也就是盗梦空间里的 limbo）！&lt;/li&gt;
&lt;li&gt;有人会觉得 JS 坑，怎么能出现这种情况；其实问题不大，因为此时代码已经报错了，后面的代码想执行也没机会。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;细节参见我的另一篇文章《&lt;a href=&#34;https://zhuanlan.zhihu.com/p/28117094&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS变量封禁大法：薛定谔的X&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;以上，就是一个 let 引发的思考。&lt;/p&gt;

&lt;p&gt;重要参考：&lt;a href=&#34;https://dmitripavlutin.com/variables-lifecycle-and-why-let-is-not-hoisted/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JavaScript variables lifecycle: why let is not hoisted&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>this 的值到底是什么？一次说清楚</title>
      <link>http://fangyinghang.com/2016/this-in-js/</link>
      <pubDate>Sun, 20 Nov 2016 13:39:30 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2016/this-in-js/</guid>
      <description>

&lt;p&gt;你可能遇到过这样的 JS 面试题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
  foo: function(){
    console.log(this)
  }
}

var bar = obj.foo
obj.foo() // 打印出的 this 是 obj
bar() // 打印出的 this 是 window
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请解释最后两行函数的值为什么不一样。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;初学者关于 this 的理解一直很模糊。今天这篇文章就要一次讲清楚了。&lt;/p&gt;

&lt;p&gt;而且这个解释，你在别的地方看不到。看懂这篇文章，所有关于 this 的面试题，都是小菜。&lt;/p&gt;

&lt;h2 id=&#34;函数调用&#34;&gt;函数调用&lt;/h2&gt;

&lt;p&gt;首先需要从函数的调用开始讲起。&lt;/p&gt;

&lt;p&gt;JS（ES5）里面有三种函数调用形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func(p1, p2) 
obj.child.method(p1, p2)
func.call(context, p1, p2) // 先不讲 apply
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。&lt;/p&gt;

&lt;p&gt;从看到这篇文章起，你一定要记住，第三种调用形式，才是正常调用形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func.call(context, p1, p2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他两种都是语法糖，可以等价地变为 call 形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func(p1, p2) 等价于
func.call(undefined, p1, p2)

obj.child.method(p1, p2) 等价于
obj.child.method.call(obj.child, p1, p2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请记下来。（我们称此代码为「转换代码」，方便下文引用）&lt;/p&gt;

&lt;p&gt;至此我们的函数调用只有一种形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func.call(context, p1, p2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，this 就好解释了 this，就是上面代码中的 context。就这么简单。&lt;/p&gt;

&lt;p&gt;也就是说 &lt;strong&gt;this 是你 call 一个函数时传的第一个参数&lt;/strong&gt;，
只是由于你从来不用 call 形式的函数调用，所以你一直不知道。&lt;/p&gt;

&lt;h2 id=&#34;func-p1-p2-里的-this&#34;&gt;func(p1, p2) 里的 this&lt;/h2&gt;

&lt;p&gt;先看 func(p1, p2) 中的 this 如何确定：&lt;/p&gt;

&lt;p&gt;当你写下面代码时&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func(){
  console.log(this)
}

func()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等价于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func(){
  console.log(this)
}

func.call(undefined) // 可以简写为 func.call()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则：&lt;/p&gt;

&lt;p&gt;如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）
因此上面的打印结果是 window。&lt;/p&gt;

&lt;p&gt;如果你希望这里的 this 不是 window，很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func.call(obj) // 那么里面的 this 就是 obj 对象了
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;obj-child-method-p1-p2-里的-this&#34;&gt;obj.child.method(p1, p2) 里的 this&lt;/h2&gt;

&lt;p&gt;再看 obj.child.method(p1, p2) 的 this 如何确定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
  foo: function(){
    console.log(this)
  }
}

obj.foo() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照「转换代码」，我们将 obj.foo() 转换为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj.foo.call(obj)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，this 就是 obj。搞定。&lt;/p&gt;

&lt;p&gt;回到题目：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
  foo: function(){
    console.log(this)
  }
}

var bar = obj.foo
obj.foo() // 转换为 obj.foo.call(obj)，this 就是 obj
bar() 
// 转换为 bar.call()
// 由于没有传 context
// 所以 this 就是 undefined
// 最后浏览器给你一个默认的 this —— window 对象
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;语法&#34;&gt;[ ] 语法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function fn (){ console.log(this) }
var arr = [fn, fn2]
arr[0]() // 这里面的 this 又是什么呢？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以把 arr[0]( ) 想象为arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr[0]() 
假想为  arr.0()
然后转换为 arr.0.call(arr)
那么里面的 this 就是 arr 了 :)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;this 就是你 call 一个函数时，传入的第一个参数。（请务必背下来「this 就是 call 的第一个参数」）
如果你的函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式。&lt;/p&gt;

&lt;p&gt;以后你遇到所有跟 this 有关的笔试题，都不会有疑问了。&lt;/p&gt;

&lt;p&gt;完。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>