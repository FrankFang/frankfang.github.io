<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>方应杭的个人网站</title>
    <link>http://fangyinghang.com/</link>
    <description>Recent content in 方应杭的个人网站 </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 08 Nov 2018 04:04:02 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>我的经历</title>
      <link>http://fangyinghang.com/my/resume/</link>
      <pubDate>Thu, 08 Nov 2018 04:04:02 +0800</pubDate>
      
      <guid>http://fangyinghang.com/my/resume/</guid>
      <description>&lt;p&gt;毕业于华中科技大学软件工程专业，先后在腾讯、阿里巴巴、彩程担任前端工程师。
现在在 &lt;a href=&#34;https://jirengu.com&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;饥人谷&lt;/a&gt; 讲课、开发、写作。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;技术栈&#34;&gt;技术栈&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Web 前端开发技术（CSS、JavaScript、TypeScript、Vue、React、Angular 等）&lt;/li&gt;
&lt;li&gt;Web 后端开发技术（Ruby on Rails、Node.js 等）&lt;/li&gt;
&lt;li&gt;正在学习 Kotlin、Swift&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;工具箱&#34;&gt;工具箱&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;编辑器喜欢用 vim、WebStorm、RubyMine，&lt;a href=&#34;https://jscode.me/t/topic/851&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;vim 配置&lt;/a&gt; 还挺简洁的。&lt;/li&gt;
&lt;li&gt;在 iTerm2.app + zshell 里运行命令行&lt;/li&gt;
&lt;li&gt;使用 Paste.app 管理剪切板&lt;/li&gt;
&lt;li&gt;使用 xScope + Sip + Sketch 切图&lt;/li&gt;
&lt;li&gt;使用印象笔记管理知识&lt;/li&gt;
&lt;li&gt;使用 The Hit List.app + Tower.im 管理工作任务&lt;/li&gt;
&lt;li&gt;讲课时非常喜欢用 &lt;a href=&#34;https://detail.tmall.com/item.htm?id=17866298588&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Wacom 数位板&lt;/a&gt; 演示思路&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>我的课程</title>
      <link>http://fangyinghang.com/my/courses/</link>
      <pubDate>Thu, 08 Nov 2018 04:04:02 +0800</pubDate>
      
      <guid>http://fangyinghang.com/my/courses/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/63308031-98f4-4907-ade4-c22d4aa82f27&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;React 入门（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/6f105ef5-8969-4863-82e7-beb162ddc5b3&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;TypeScript 入门（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/9ff75915-a19f-451d-b3a5-85feed5a6bc1&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;SCSS 入门（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/6d63da67-6eea-4711-aeb4-0c3a949341dc&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;自制 Vue UI 框架（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/24f54465-854f-4de7-9808-72a0bf5b3181&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS 深入浅出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/12a78a03-35f9-42ea-9b37-540540460f6e&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ES6 深入浅出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/003b1951-22af-4821-ad80-d2880c0074eb&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;CSS 深入浅出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/ec3a5e28-02da-47d6-9226-927db23e82a2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;前端零基础入门&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>微信订阅</title>
      <link>http://fangyinghang.com/wechat-subscribe/</link>
      <pubDate>Thu, 08 Nov 2018 03:43:41 +0800</pubDate>
      
      <guid>http://fangyinghang.com/wechat-subscribe/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/me/qrcode.jpg&#34; alt=&#34;扫码关注&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>联系方式</title>
      <link>http://fangyinghang.com/contacts/</link>
      <pubDate>Thu, 08 Nov 2018 03:43:41 +0800</pubDate>
      
      <guid>http://fangyinghang.com/contacts/</guid>
      <description>&lt;p&gt;邮箱：fangyinghang # foxmail.com&lt;/p&gt;

&lt;p&gt;知乎：&lt;a href=&#34;https://www.zhihu.com/people/zhihusucks/answers/by_votes&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;zhihusucks&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jQuery 都过时了，那我还学它干嘛？</title>
      <link>http://fangyinghang.com/2018/why-still-jquery/</link>
      <pubDate>Mon, 15 Oct 2018 16:22:04 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2018/why-still-jquery/</guid>
      <description>

&lt;p&gt;今天饥人谷的新生问我&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;请问现在我还需要学习 jQuery 吗？听你在知乎说 jQuery 已经过时了，是不是就不用学了？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;短答案&#34;&gt;短答案&lt;/h2&gt;

&lt;p&gt;jQuery 还是可以学一学的，学了之后对写代码和封装库很有帮助。&lt;/p&gt;

&lt;p&gt;现在的「新人」依然可以学习 jQuery 的思想，因为以「新人」的水平，直接理解 Vue / React 的思想难度较大，jQuery 是一个很不错的中间过渡，因为 jQuery 也蕴含了非常多的编程套路。&lt;/p&gt;

&lt;p&gt;但是如果你不想学，就不学吧。直接去学 Vue / React 会难一点，但也能学会。&lt;/p&gt;

&lt;h2 id=&#34;长答案&#34;&gt;长答案：&lt;/h2&gt;

&lt;p&gt;jQuery 当然过时了。&lt;/p&gt;

&lt;p&gt;距离我上次在项目中使用 jQuery，可能已经快两年时间了（除去上课时演示功能时用 jQuery）。回想我学习 jQuery 的过程，还挺神奇的。&lt;/p&gt;

&lt;p&gt;当年我在大学的技术小组里做 C# 网站开发，需要用到 jQuery 特效，组里的一名小伙伴会用一点 jQuery，很快就用 .animate 做出了让我啧啧称奇的特效。我觉得 jQuery 好神奇啊，虽然我当时连 JS 都不会。&lt;/p&gt;

&lt;p&gt;于是我立马买了一本《锋利的 jQuery》，硬看。&lt;/p&gt;

&lt;p&gt;什么叫「硬看」呢？因为我不会 JS，而且我并没有照着书上敲代码，仅仅使用眼睛「看 jQuery 代码」。神奇的是——我居然很快看懂了几乎整本书。以至于那位会用 jQuery 的小伙伴遇到 bug 问我时我能直接给出解答，看起来他并没有看《锋利的 jQuery》这本书（笑）。&lt;/p&gt;

&lt;p&gt;到了 2018 年，几乎已经没有新项目会使用 jQuery 来开发了；即使有，也是一件不值得拿出来炫耀的事情。那为什么我还是建议学习 jQuery 呢？&lt;/p&gt;

&lt;p&gt;原因如下。&lt;/p&gt;

&lt;h2 id=&#34;jquery-教你如何设计-api&#34;&gt;jQuery 教你如何设计 API&lt;/h2&gt;

&lt;p&gt;上文说到我一个不会 JS 的人居然能看懂 jQuery 的书，其实这不是因为我厉害，而是因为 jQuery 的 API 设计得太人性化了！&lt;/p&gt;

&lt;p&gt;举几个例子给大家看看：&lt;/p&gt;

&lt;p&gt;第一个是 jQuery 对事件监听的简化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 那时，如果不用 jQuery，监听事件（兼容 IE 6）你要这么写
if (button.addEventListener)  
  button.addEventListener(&#39;click&#39;,fn);
else if (button.attachEvent) { 
  button.attachEvent(&#39;onclick&#39;, fn);
}else {
  button.onclick = fn;
}

// 但是如果你用 jQuery，你只需要这么写
$(button).on(&#39;click&#39;, fn)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个是 jQuery 对元素选择的简化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 如果你想获取 .nav &amp;gt; .navItem 对应的所有元素，用 jQuery 是这样写的
$(&#39;.nav &amp;gt; .navItem&#39;)

// 在 IE 6 上，你得这么写
var navItems = document.getElementsByClassName(&#39;navItem&#39;)
var result = []
for(var i = 0; i &amp;lt; navItems.length; i++){
  if(navItems[i].parentNode.className.match(/\bnav\b/){
    result.push(navItems[i])
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有没有发现 jQuery 的代码一读就读懂了？可读性非常强！&lt;/p&gt;

&lt;p&gt;当时我作为一个新人，每每看到 jQuery 那优雅的 API，都禁不住去思考 jQuery 到底是怎么实现的，我自己能不能实现出来（但我并不推荐看 jQuery 源码）。本着这样的想法，我学会了很多编程技巧。&lt;/p&gt;

&lt;p&gt;为什么有些人代码水平老是提不高了，就是因为不会造轮子，不会设计优雅的 API，更不会实现优雅的 API，只会调用其他库或框架提供的功能（中枪的举手）。&lt;/p&gt;

&lt;p&gt;而 jQuery 则提供了一个简单而又经典的范例供大家学习。&lt;/p&gt;

&lt;p&gt;不信的话我们就来看看 jQuery 用到了哪些所谓的设计模式（其实就是编程套路）吧。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;发布订阅模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var eventHub = $({})
eventHub.on(&#39;xxx&#39;, function(){ console.log(&#39;收到&#39;) })
eventHub.trigger(&#39;xxx&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用原型继承实现插件系统&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.fn.modal = function(){ ... }
$(&#39;#div1&#39;).modal()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vue 2 的插件也是类似的思路哦&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事件委托&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;).on(&#39;click&#39;, &#39;span&#39;, function(){...})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说实话，你在 2018 年找前端让他写一个事件委托，我保证 90% 写出来的代码都是有「明显」bug 的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;链式调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;).text(&#39;hi&#39;).addClass(&#39;red&#39;).animate({left: 100})
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数重载（伪）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(fn)
$(&#39;div&#39;)
$(div)
$($(div))
$(&#39;span&#39;, &#39;#scope1&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会发现 $ 这个函数的参数可以是函数、字符串、元素和 jQuery 对象，甚至还能接受多个参数，这种重载是怎么做到的？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;命名空间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 你的插件在一个 button 上绑定了很多事件
$button.on(&#39;click.plugin&#39;, function(){...})
$button.on(&#39;mouseenter.plugin&#39;, function(){...})
// 然后你想在某个时刻移除以上所有事件
$button.off(&#39;.plugin&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不用 jQuery 就很麻烦了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;高阶函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fn2 = $.proxy(fn1, asThis, param1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$.proxy 接受一个函数，返回一个新的函数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其他就不一一列举了。&lt;/p&gt;

&lt;h2 id=&#34;jquery-的-api-风格依然在流行&#34;&gt;jQuery 的 API 风格依然在流行&lt;/h2&gt;

&lt;p&gt;我们把 jQuery 和 Axios 做一下对比：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajax({url:&#39;/api&#39;, method:&#39;get&#39;})
$.get(&#39;/api&#39;).then(fn1,fn2)

axios({ url: &#39;/api&#39;, method: &#39;get&#39;})
axios.get(&#39;/api&#39;).then(fn1, fn2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么 2018 年流行的 axios 跟 jQuery.ajax 这么相像呢？&lt;/p&gt;

&lt;p&gt;因为 jQuery 的 API 实在太好用了！搞得新库根本没法超越它，没有办法设计出更简洁的 API 了。毕竟 jQuery 也是在前端界流行近十年。&lt;/p&gt;

&lt;p&gt;所以你学了 jQuery 很容易过渡其他类似的新库。&lt;/p&gt;

&lt;h2 id=&#34;jquery-也能做-mvc&#34;&gt;jQuery 也能做 MVC&lt;/h2&gt;

&lt;p&gt;很多人以为前端框架是从 Vue、React 和 Angular 才开始的，其实 jQuery 时代早就有基于 jQuery 的 MV* 库了，比如著名的 Backbone.js 和 Marionette.js。&lt;/p&gt;

&lt;p&gt;看看下面的 Backbone 应用代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var TodoView = Backbone.View.extend({
    tagName:  &#39;div&#39;,
    template: _.template($(&#39;#item-template&#39;).html()),
    events: {
        &#39;click .toggle&#39;: &#39;xxx&#39;,
    },
    initialize: function () {
        this.listenTo(this.model, &#39;change&#39;, this.render);
    },
    render: function () {
        if (this.model.changed.id !== undefined) {return; }
        this.$el.html(this.template(this.model.toJSON()));
        return this;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AngularJS、Vue 1.x、Vue 2.x 其实都是顺着 Backbone MVC 的思路慢慢优化、改造得来的，如果你提前了解 Backbone 作为知识铺垫，那么理解 Vue 是非常容易的。如果面试官问你 MVC 和 MVVM 的区别，你也是很容易就可以答出来的。&lt;/p&gt;

&lt;p&gt;最后就引用我之前的一个回答作为结尾来说明学习 jQuery 意义：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/20521802/answer/290354219&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;完全理解jQuery源代码，在前端行业算什么水平？&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;说明你&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;精通正则表达式&lt;/li&gt;
&lt;li&gt;了解闭包&lt;/li&gt;
&lt;li&gt;了解原型链&lt;/li&gt;
&lt;li&gt;精通 DOM API&lt;/li&gt;
&lt;li&gt;了解各种设计模式（事件、Promise、伪重载、装饰器模式等）&lt;/li&gt;
&lt;li&gt;精通 DOM 事件&lt;/li&gt;
&lt;li&gt;了解旧浏览器的各种特性（bug）&lt;/li&gt;
&lt;li&gt;了解模块化&lt;/li&gt;
&lt;li&gt;了解浏览器渲染原理&lt;/li&gt;
&lt;li&gt;精通 AJAX&lt;/li&gt;
&lt;li&gt;了解 HTTP 请求&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以秒杀中国 80% 的前端&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>我写了一个基于 Vue 的 UI 框架——轱辘 UI</title>
      <link>http://fangyinghang.com/2018/gulu-ui/</link>
      <pubDate>Fri, 03 Aug 2018 16:32:18 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2018/gulu-ui/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://frankfang.github.io/gulu/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官方文档&lt;/a&gt; | &lt;a href=&#34;https://github.com/FrankFang/gulu&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;源码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;轱辘 UI 是一个不太一样的 UI 框架。&lt;/p&gt;

&lt;p&gt;本 UI 框架是一个「面向源码阅读者」的框架。如果对你有帮助，请不要吝惜你的 star。&lt;/p&gt;

&lt;p&gt;也就是说，我制作这个框架的目的就是让前端新人学习轮子的制作思路。所有代码都追求可读性。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你可以通过查看逐个 commit 来学习本框架的制作思路&lt;/li&gt;
&lt;li&gt;也可以通过我&lt;a href=&#34;https://xiedaimala.com/courses/6d63da67-6eea-4711-aeb4-0c3a949341dc&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;录制的视频&lt;/a&gt;来学习
（抱歉，由于制作非常耗时，所以视频是收费的。不过项目搭建过程的录屏是&lt;strong&gt;免费&lt;/strong&gt;的，这几节视频能帮你快速从零开始本项目。）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你想从第一个commit 开始看，请点击&lt;a href=&#34;https://github.com/FrankFang/gulu/commits/master?after=36fbd6867d0a223184ad67e3d2bc3569e88847e0+104&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果你对代码有疑问，欢迎&lt;a href=&#34;https://github.com/frankfang/gulu/issues&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;提issue&lt;/a&gt;，我会回答你的疑问。也可以在本文末尾加群咨询。&lt;/p&gt;

&lt;p&gt;本 UI 框架是基于 Vue 2 实现的。&lt;/p&gt;

&lt;p&gt;注意：本 UI 框架的代码尚未完全完工（目前代码大概完成 50%），请不要在生产环境中使用本 UI 框架。&lt;/p&gt;

&lt;h2 id=&#34;你能学到什么&#34;&gt;你能学到什么&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;单元测试、覆盖率、持续集成等工程概念&lt;/li&gt;
&lt;li&gt;重构、TDD/BDD、设计模式、单向数据流等技术概念&lt;/li&gt;
&lt;li&gt;Vue 的几乎所有功能，并且是深入理解这些功能，而不是肤浅理解&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;有哪些轮子&#34;&gt;有哪些轮子&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;简单轮子：按钮、输入框、网格、布局、Toast、Tabs、Popover、手风琴（代码已完成）&lt;/li&gt;
&lt;li&gt;进阶轮子：级联选择、无缝轮播、响应式导航条、分页、表单验证、Table、图片上传、Sticky、Tree、Suggestion、Datepicker（代码未完成）&lt;/li&gt;
&lt;li&gt;其他：路由、状态管理（代码未完成）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：这只是目前的计划，具体要完成的轮子可能与上面有出入。&lt;/p&gt;

&lt;h2 id=&#34;项目特点&#34;&gt;项目特点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;使用 Travis CI 进行持续集成&lt;/li&gt;
&lt;li&gt;有丰富的单元测试，项目完成时，期望测试覆盖率超过 90%&lt;/li&gt;
&lt;li&gt;自说明的代码，即使没有注释，你也能看懂&lt;/li&gt;
&lt;li&gt;初期我使用 parcel 构建方便新人上手，后期改为 Vue Cli 3 以实现更多功能&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;我几年前曾经发表过《&lt;a href=&#34;https://juejin.im/post/58ef6004ac502e006c16f2d6&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;笨办法学前端&lt;/a&gt;》一文，
当时我觉得开源社区里虽然有很多不错的库，但是这些库都是以实用为主，其源码并不适合&lt;strong&gt;新人&lt;/strong&gt;阅读。&lt;/p&gt;

&lt;p&gt;于是我业余时间用原生 JS 造了几个轮子放在 GitHub，没想到居然有几百人关注，还希望我能发布更详细的教程。&lt;/p&gt;

&lt;p&gt;但是我当时并没有时间来做更详细的教程。&lt;/p&gt;

&lt;p&gt;现在我终于……还是很忙，不过我决定用每周六和周日来录制「造轮子」的视频。&lt;/p&gt;

&lt;p&gt;这一次为了顺应前端的潮流，我直接采用 Vue 2 来造轮子。如果你正在学习 Vue 2，那么轱辘 UI 的源码会非常适合你阅读。&lt;/p&gt;

&lt;h2 id=&#34;视觉稿&#34;&gt;视觉稿&lt;/h2&gt;

&lt;p&gt;本 UI 框架借鉴了一些成熟 UI 框架（如 Framework7、Element UI 和 Ant Design）的外观，简化之后我自己制作了一个&lt;a href=&#34;https://www.yuque.com/u29422/gulu/artboards/22283&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;视觉稿&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果你发现视觉稿有什么不足的地方，可以直接在上面留言，我也会看到。&lt;/p&gt;

&lt;h2 id=&#34;为什么叫轱辘ui&#34;&gt;为什么叫轱辘UI&lt;/h2&gt;

&lt;p&gt;因为轱辘就是「轮子」的意思，这个项目几乎就是在造轮子。&lt;/p&gt;

&lt;h2 id=&#34;微信交流群&#34;&gt;微信交流群&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qr.jirengu.com/api/taskUrl?tid=8&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;点击查看二维码&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我用了两个月的时间才理解 let</title>
      <link>http://fangyinghang.com/2017/let-in-js/</link>
      <pubDate>Thu, 27 Jul 2017 13:39:30 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2017/let-in-js/</guid>
      <description>

&lt;p&gt;当然不是说用完整的两个月时间来理解 let，而是零零碎碎地理解，同时我还要想着怎么写出一篇文章把这个事情说清楚。&lt;/p&gt;

&lt;p&gt;在 let 刚出来的时候，我就「以为」我理解了 let。然鹅在过去的两个月里，我对 let 的理解发生了一波三折的变化。&lt;/p&gt;

&lt;p&gt;我写这篇文章，是希望我的学习过程，能对你自学有帮助。&lt;/p&gt;

&lt;h2 id=&#34;初识-let&#34;&gt;初识 let&lt;/h2&gt;

&lt;p&gt;跟很多人一样，我第一次了解 let 的特性是从 MDN 的文档：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我得到的信息有这么几条：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;let 声明的变量的作用域是块级的；&lt;/li&gt;
&lt;li&gt;let 不能重复声明已存在的变量；&lt;/li&gt;
&lt;li&gt;let 有暂时死区，不会被提升。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大部分人应该都是这么认为的，我也是这么理解的。&lt;/p&gt;

&lt;p&gt;这个理解「没有问题」，但是不够「全面和深刻」。&lt;/p&gt;

&lt;h2 id=&#34;第一次质疑&#34;&gt;第一次质疑&lt;/h2&gt;

&lt;p&gt;我第一次质疑我的理解是在遇到 for 循环的时候，代码如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代码段1
var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li
for( var i=0; i&amp;lt;liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家都知道依次点击 li 会打印出 5 个 5。如果把 var i 改成 let i，就会分别打印出 0、1、2、3、4：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代码段2
var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li
for( let i=0; i&amp;lt;liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，用我之前的知识来理解这个代码是不能自圆其说的。因为代码中依然只声明了一个 i，在 for 循环结束后，i 的值还是会变成 5 才对。&lt;/p&gt;

&lt;p&gt;这说明我的理解有误。&lt;/p&gt;

&lt;p&gt;于是我去看 MDN 的例子，发现鸡贼的 MDN 巧妙地避开了这个问题，它的例子是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;你看 MDN 的例子，在每次循环的时候用 let j 保留的 i 的值，所以在 i 变化的时候，j 并不会变化。而console.log 的是 j，所以不会出现 5 个 5。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么 MDN 要故意声明一个 j 呢，为什么不直接用 i 呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我猜测 MDN 为了简化知识，隐瞒了什么。&lt;/p&gt;

&lt;p&gt;于是我去看了看 ES 文档，其中的 &lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement-runtime-semantics-labelledevaluation&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;13.7.4.7 章节&lt;/a&gt;
清楚地说明了个中缘由，但是由于说得太清楚了，很多人都看不下去，不信你可以试试。&lt;/p&gt;

&lt;p&gt;我说一下我的理解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;for( let i = 0; i&amp;lt; 5; i++)&lt;/code&gt; 这句话的圆括号之间，有一个隐藏的作用域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for( let i = 0; i&amp;lt; 5; i++) { 循环体 }&lt;/code&gt; 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。&lt;/li&gt;
&lt;li&gt;其他细节就不说了，太细碎了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说上面的代码段2可以近似近似近似地理解为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代码段3
var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li
for( let i=0; i&amp;lt;liList.length; i++){
  let i = 隐藏作用域中的i // 看这里看这里看这里
  liList[i].onclick = function(){
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那样的话，5 次循环，就会有 5 个不同的 i，console.log 出来的 i 当然也是不同的值。&lt;/p&gt;

&lt;p&gt;再加上隐藏作用域里的 i，一共有 6 个 i。&lt;/p&gt;

&lt;p&gt;这就是 MDN 加那句 &lt;code&gt;let j = i&lt;/code&gt; 的原因：方便新人理解。&lt;/p&gt;

&lt;p&gt;总得来说就是 let/const 在与 for 一起用时，会有一个 perIterationBindings 的概念（一种语法糖）。&lt;/p&gt;

&lt;p&gt;从此之后，我就开始怀疑我对 let 的所有理解了。&lt;/p&gt;

&lt;h2 id=&#34;第二次质疑&#34;&gt;第二次质疑&lt;/h2&gt;

&lt;p&gt;我在 StackOverflow 上闲逛的时候，无意中发现了一个是关于「let 到底有没有提升」的问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Are variables declared with let or const not hoisted in ES6?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中一个高票回答认为 JS 中所有的声明（var/let/const/function/class），都存在提升，理由是如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = &amp;quot;global&amp;quot;;
// function scope:
(function() {
    x; // not &amp;quot;global&amp;quot;

    var/let/… x;
}());
// block scope (not for `var`s):
{
    x; // not &amp;quot;global&amp;quot;

    let/const/… x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我觉得他说得挺有道理的。于是我又去 MDN 和 ECMAScript 翻了翻，发现两处疑点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MDN 关于 let 是否存在提升的章节，被编辑了两次，第一次说存在提升，第二次说不存在提升（参考 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let%24compare?locale=en-US&amp;amp;to=1242757&amp;amp;from=1242229&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;2017 年 3 月 10 号的变更记录&lt;/a&gt;）。也就是说 MDN 的维护者都在这个问题上产生过分歧，更何况我们了。&lt;/li&gt;
&lt;li&gt;ES 文档里出现了「var/let hoisting」字样。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;鉴于此，我认为应该尊重 ES 文档，认为 let 确实存在提升。只不过由于暂时死区的限制，你不能在 let x 之前使用 let（详见我的那篇 let 声明会提升（hoist）吗？）。&lt;/p&gt;

&lt;h2 id=&#34;故事并没有结束&#34;&gt;故事并没有结束&lt;/h2&gt;

&lt;p&gt;当一个疑问一直存在你脑中时，你会在潜意识中不停地对它进行消化和思考。&lt;/p&gt;

&lt;p&gt;上面说到我认为 let 存在提升的主要原因是 ES 文档中出现了「var/let hoisting」字样。&lt;/p&gt;

&lt;p&gt;但是我在咨询 TC39 的成员 &lt;a href=&#34;https://twitter.com/rwaldron&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Rick Waldron&lt;/a&gt; 时，他是这么说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You&amp;rsquo;re misunderstanding the intention of that (non-normative) Note. let and const do not hoist as var and function decls do.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而且还细心地专门写了一个 &lt;a href=&#34;https://gist.github.com/rwaldron/ca35924d59ddc60a6aa165e1e4a3acda&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;gist&lt;/a&gt; 来详细解释（twitter 有 140 字限制）。&lt;/p&gt;

&lt;p&gt;既然 TC39 的 representative 都说了 let hoisting 不是一个正式词汇，那我就应该重新思考一下什么是「提升」了。&lt;/p&gt;

&lt;p&gt;于是就有了这篇文章，我想要说一下我对「提升」的理解。你看完之后，就知道 let 到底有没有「提升」。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先明确一点：提升不是一个技术名词。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」&lt;/p&gt;

&lt;p&gt;有的地方把创建说成是声明（declare），为了将这个概念与变量声明区别开，我故意不使用声明这个字眼。&lt;/p&gt;

&lt;p&gt;有的地方把初始化叫做绑定（binding），但我感觉这个词不如初始化形象。&lt;/p&gt;

&lt;h2 id=&#34;创建-初始化和赋值&#34;&gt;创建、初始化和赋值&lt;/h2&gt;

&lt;h3 id=&#34;我们来看看-var-声明的-创建-初始化和赋值-过程&#34;&gt;我们来看看 var 声明的「创建、初始化和赋值」过程&lt;/h3&gt;

&lt;p&gt;假设有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fn(){
  var x = 1
  var y = 2
}
fn()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在执行 fn 时，会有以下过程（不完全）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;进入 fn，为 fn 创建一个环境。&lt;/li&gt;
&lt;li&gt;找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。&lt;/li&gt;
&lt;li&gt;将这些变量「初始化」为 undefined。&lt;/li&gt;
&lt;li&gt;开始执行代码&lt;/li&gt;
&lt;li&gt;x = 1 将 x 变量「赋值」为 1&lt;/li&gt;
&lt;li&gt;y = 2 将 y 变量「赋值」为 2&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。&lt;/p&gt;

&lt;p&gt;这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。&lt;/p&gt;

&lt;h3 id=&#34;接下来来看-function-声明的-创建-初始化和赋值-过程&#34;&gt;接下来来看 function 声明的「创建、初始化和赋值」过程&lt;/h3&gt;

&lt;p&gt;假设代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn2()

function fn2(){
  console.log(2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JS 引擎会有以下过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找到所有用 function 声明的变量，在环境中「创建」这些变量。&lt;/li&gt;
&lt;li&gt;将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。&lt;/li&gt;
&lt;li&gt;开始执行代码 fn2()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」。&lt;/p&gt;

&lt;h3 id=&#34;接下来看-let-声明的-创建-初始化和赋值-过程&#34;&gt;接下来看 let 声明的「创建、初始化和赋值」过程&lt;/h3&gt;

&lt;p&gt;假设代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  let x = 1
  x = 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只看 {} 里面的过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找到所有用 let 声明的变量，在环境中「创建」这些变量&lt;/li&gt;
&lt;li&gt;开始执行代码（注意现在还没有初始化）&lt;/li&gt;
&lt;li&gt;执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）&lt;/li&gt;
&lt;li&gt;执行 x = 2，对 x 进行「赋值」&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就解释了为什么在 let x 之前使用 x 会报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = &#39;global&#39;
{
  console.log(x) // Uncaught ReferenceError: x is not defined
  let x = 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因有两个&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;console.log(x) 中的 x 指的是下面的 x，而不是全局的 x&lt;/li&gt;
&lt;li&gt;执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看到这里，你应该明白了 let 到底有没有提升：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;let 的「创建」过程被提升了，但是初始化没有提升。&lt;/li&gt;
&lt;li&gt;var 的「创建」和「初始化」都被提升了。&lt;/li&gt;
&lt;li&gt;function 的「创建」「初始化」和「赋值」都被提升了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后看 const，其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程。&lt;/p&gt;

&lt;p&gt;这四种声明，用下图就可以快速理解：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所谓暂时死区，就是&lt;strong&gt;不能在初始化之前，使用变量&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;完了吗&#34;&gt;完了吗？&lt;/h2&gt;

&lt;p&gt;故事依然没有结束，这周我在知乎上&lt;a href=&#34;https://www.zhihu.com/question/62966713&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;问了一个问题&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如何理解 let x = x 报错之后，再次 let x 依然会报错？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个问题是饥人谷的学生问我的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个问题说明：如果 let x 的初始化过程失败了，那么&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;x 变量就将永远处于 created 状态。&lt;/li&gt;
&lt;li&gt;你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。&lt;/li&gt;
&lt;li&gt;由于 x 无法被初始化，所以 x 永远处在暂时死区（也就是盗梦空间里的 limbo）！&lt;/li&gt;
&lt;li&gt;有人会觉得 JS 坑，怎么能出现这种情况；其实问题不大，因为此时代码已经报错了，后面的代码想执行也没机会。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;细节参见我的另一篇文章《&lt;a href=&#34;https://zhuanlan.zhihu.com/p/28117094&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS变量封禁大法：薛定谔的X&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;以上，就是一个 let 引发的思考。&lt;/p&gt;

&lt;p&gt;重要参考：&lt;a href=&#34;https://dmitripavlutin.com/variables-lifecycle-and-why-let-is-not-hoisted/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JavaScript variables lifecycle: why let is not hoisted&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JS 的 new 到底是干什么的？</title>
      <link>http://fangyinghang.com/2016/new-in-js/</link>
      <pubDate>Mon, 12 Dec 2016 01:45:22 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2016/new-in-js/</guid>
      <description>

&lt;p&gt;大部分讲 new 的文章会从面向对象的思路讲起，但是我始终认为，在解释一个事物的时候，不应该引入另一个更复杂的事物。&lt;/p&gt;

&lt;p&gt;今天我从「省代码」的角度来讲 new。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;想象我们在制作一个策略类战争游戏，玩家可以操作一堆士兵攻击敌方。&lt;/p&gt;

&lt;p&gt;我们着重来研究一下这个游戏里面的「制造士兵」环节。&lt;/p&gt;

&lt;p&gt;一个士兵的在计算机里就是一堆属性，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/new-in-js/1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们只需要这样就可以制造一个士兵：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var 士兵 = {
  ID: 1, // 用于区分每个士兵
  兵种:&amp;quot;美国大兵&amp;quot;,
  攻击力:5,
  生命值:42, 
  行走:function(){ /*走俩步的代码*/},
  奔跑:function(){ /*狂奔的代码*/  },
  死亡:function(){ /*Go die*/    },
  攻击:function(){ /*糊他熊脸*/   },
  防御:function(){ /*护脸*/       }
}

兵营.制造(士兵)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;制造一百个士兵&#34;&gt;制造一百个士兵&lt;/h2&gt;

&lt;p&gt;如果需要制造 100 个士兵怎么办呢？&lt;/p&gt;

&lt;p&gt;循环 100 次吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var 士兵们 = []
var 士兵
for(var i=0; i&amp;lt;100; i++){
  士兵 = {
    ID: i, // ID 不能重复
    兵种:&amp;quot;美国大兵&amp;quot;,
    攻击力:5,
    生命值:42, 
    行走:function(){ /*走俩步的代码*/}，
    奔跑:function(){ /*狂奔的代码*/  },
    死亡:function(){ /*Go die*/    },
    攻击:function(){ /*糊他熊脸*/   },
    防御:function(){ /*护脸*/       }
  }
  士兵们.push(士兵)
}

兵营.批量制造(士兵们)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;哎呀好简单。&lt;/p&gt;

&lt;h2 id=&#34;质疑&#34;&gt;质疑&lt;/h2&gt;

&lt;p&gt;上面的代码存在一个问题：浪费了很多内存。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;行走、奔跑、死亡、攻击、防御这五个动作对于每个士兵其实是一样的，只需要各自引用同一个函数就可以了，没必要重复创建 100 个行走、100个奔跑……&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这些士兵的兵种和攻击力都是一样的，没必要创建 100 次。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;只有 ID 和生命值需要创建 100 次，因为每个士兵有自己的 ID 和生命值。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;改进&#34;&gt;改进&lt;/h2&gt;

&lt;p&gt;看过我们的专栏以前文章（&lt;a href=&#34;https://zhuanlan.zhihu.com/p/23090041?refer=study-fe&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS 原型链&lt;/a&gt;）的同学肯定知道，用原型链可以解决重复创建的问题：我们先创建一个「士兵原型」，然后让「士兵」的 &lt;strong&gt;proto&lt;/strong&gt; 指向「士兵原型」&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var 士兵原型 = {
  兵种:&amp;quot;美国大兵&amp;quot;,
  攻击力:5,
  行走:function(){ /*走俩步的代码*/}，
  奔跑:function(){ /*狂奔的代码*/  },
  死亡:function(){ /*Go die*/    },
  攻击:function(){ /*糊他熊脸*/   },
  防御:function(){ /*护脸*/       }
}
var 士兵们 = []
var 士兵
for(var i=0; i&amp;lt;100; i++){
  士兵 = {
    ID: i, // ID 不能重复
    生命值:42
  }

  /*实际工作中不要这样写，因为 __proto__ 不是标准属性*/
  士兵.__proto__ = 士兵原型 

  士兵们.push(士兵)
}

兵营.批量制造(士兵们)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;优雅&#34;&gt;优雅？&lt;/h2&gt;

&lt;p&gt;有人指出创建一个士兵的代码分散在两个地方很不优雅，于是我们用一个函数把这两部分联系起来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function 士兵(ID){
  var 临时对象 = {}

  临时对象.__proto__ = 士兵.原型

  临时对象.ID = ID
  临时对象.生命值 = 42

  return 临时对象
}

士兵.原型 = {
  兵种:&amp;quot;美国大兵&amp;quot;,
  攻击力:5,
  行走:function(){ /*走俩步的代码*/}，
  奔跑:function(){ /*狂奔的代码*/  },
  死亡:function(){ /*Go die*/    },
  攻击:function(){ /*糊他熊脸*/   },
  防御:function(){ /*护脸*/       }
}

// 保存为文件：士兵.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以愉快地引用「士兵」来创建士兵了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var 士兵们 = []
for(var i=0; i&amp;lt;100; i++){
  士兵们.push(士兵(i))
}

兵营.批量制造(士兵们)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;js-之父的关怀&#34;&gt;JS 之父的关怀&lt;/h2&gt;

&lt;p&gt;JS 之父创建了 new 关键字，可以让我们少写几行代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/new-in-js/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;只要你在士兵前面使用 new 关键字，那么可以少做四件事情：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不用创建临时对象，因为 new 会帮你做（&lt;strong&gt;你使用「this」就可以访问到临时对象&lt;/strong&gt;）；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不用 return 临时对象，因为 new 会帮你做；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要给原型想名字了，因为 new 指定名字为 prototype。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;这一次我们用-new-来写&#34;&gt;这一次我们用 new 来写&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function 士兵(ID){
  this.ID = ID
  this.生命值 = 42
}

士兵.prototype = {
  兵种:&amp;quot;美国大兵&amp;quot;,
  攻击力:5,
  行走:function(){ /*走俩步的代码*/},
  奔跑:function(){ /*狂奔的代码*/  },
  死亡:function(){ /*Go die*/    },
  攻击:function(){ /*糊他熊脸*/   },
  防御:function(){ /*护脸*/       }
}

// 保存为文件：士兵.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是创建士兵（加了一个 new 关键字）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var 士兵们 = []
for(var i=0; i&amp;lt;100; i++){
  士兵们.push(new 士兵(i))
}

兵营.批量制造(士兵们)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;new 的作用，就是省那么几行代码。（也就是所谓的语法糖）&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;注意-constructor-属性&#34;&gt;注意 constructor 属性&lt;/h2&gt;

&lt;p&gt;new 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「士兵.prototype」加了一个 constructor 属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;士兵.prototype = {
  constructor: 士兵
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你重新对「士兵.prototype」赋值，那么这个 constructor 属性就没了，所以你应该这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;士兵.prototype.兵种 = &amp;quot;美国大兵&amp;quot;
士兵.prototype.攻击力 = 5
士兵.prototype.行走 = function(){ /*走俩步的代码*/}
士兵.prototype.奔跑 = function(){ /*狂奔的代码*/  }
士兵.prototype.死亡 = function(){ /*Go die*/    }
士兵.prototype.攻击 = function(){ /*糊他熊脸*/   }
士兵.prototype.防御 = function(){ /*护脸*/       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者你也可以自己给 constructor 重新赋值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;士兵.prototype = {
  constructor: 士兵,
  兵种:&amp;quot;美国大兵&amp;quot;,
  攻击力:5,
  行走:function(){ /*走俩步的代码*/},
  奔跑:function(){ /*狂奔的代码*/  },
  死亡:function(){ /*Go die*/    },
  攻击:function(){ /*糊他熊脸*/   },
  防御:function(){ /*护脸*/       }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>从培训班出来之后找工作的经历，教会了我这五件事</title>
      <link>http://fangyinghang.com/2016/five-key-learnings-from-the-post-bootcamp-job-search/</link>
      <pubDate>Sat, 03 Dec 2016 01:25:35 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2016/five-key-learnings-from-the-post-bootcamp-job-search/</guid>
      <description>

&lt;p&gt;这是 &lt;a href=&#34;https://medium.freecodecamp.com/5-key-learnings-from-the-post-bootcamp-job-search-9a07468d2331&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Medium 上的一篇文章&lt;/a&gt;（已有 5900 个赞），讲的是国外一个培训出来的程序员，用三个月时间，找到了一份年薪 12 万美元的工作，并从中得到的五个忠告的故事。&lt;/p&gt;

&lt;p&gt;我觉得他总结得很好，尤其是心态和方法，非常值得学习。对正在找工作的同学非常有用。&lt;/p&gt;

&lt;p&gt;译文开始。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我们很少讨论，一个参加编程培训的人在毕业之后都会经历些什么，也就是他找工作的经历。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/five-key/1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我在 2016 年的 7 月完成了 Hack Reactor（一个编程培训网站，有线下课程，也有线上课程）的课程，之后用了三个月的时间才拿到 R 公司的 Offer。我一共向 291 个公司投递了简历，接到了 32 个电话面试，16 次技术面试，13 次代码面试，11次现场面试，最终得到 8 个 Offer。薪水范围从 60k 到 125k 美元不等（年薪），公司遍布美国各个州，既有前端职位又有全栈职位。整体来看，我的命中率是 2.8%。&lt;/p&gt;

&lt;p&gt;如果我开始找工作前知道这五个忠告，也许我会更顺利。&lt;/p&gt;

&lt;h2 id=&#34;忠告一-接触真人&#34;&gt;忠告一：接触真人&lt;/h2&gt;

&lt;p&gt;起初我找工作用的是「广撒网」的方式。我在很多网站上投简历，比如 Indeed、AngelList、LinkedIn、StackOverflow、Hacker News。我甚至到 Craigslist（相当于 58 同城）上投简历了。&lt;/p&gt;

&lt;p&gt;只要一个职位涉及 React、Node 或者 JS，我就投简历。所以最开始的一周里，我每天要投 15 到 20 封简历。&lt;/p&gt;

&lt;p&gt;结果可想而知，不到 5% 的公司回复我。我的简历石沉大海。&lt;/p&gt;

&lt;p&gt;直到有一天，我的室友，以前做过招聘，他给我分享了一个小技巧。他让我把简历直接发到那个公司员工的邮箱里，不管这个人是什么身份，只要这个人会去读邮件就行。&lt;/p&gt;

&lt;p&gt;从那之后，无论我投哪家公司，都会去 LinkedIn（译注：你可以也去微博搜）搜这家公司的开发人员或者 HR，把简历直接发送给那个人。&lt;/p&gt;

&lt;p&gt;大部分小公司的邮箱格式是「姓名全拼@公司名.com」，对于大公司格式可能就是「花名.姓名@公司名.com」。我还用到了 &lt;a href=&#34;http://link.zhihu.com/?target=https%3A//rapportive.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Rapportive&lt;/a&gt; 来保证邮箱地址的准确性。&lt;/p&gt;

&lt;p&gt;结果很喜人，我发了 150 多封邮件，居然有三十多封回信。&lt;/p&gt;

&lt;p&gt;而且他们给我的建议也很受用。我发现有些公司的 CEO 或者 CTO 会直接回复我，甚至直接面试我。&lt;/p&gt;

&lt;h2 id=&#34;忠告二-由小到大-先易后难&#34;&gt;忠告二：由小到大，先易后难&lt;/h2&gt;

&lt;p&gt;你可能会遇到段位为 1 的面试（比如一个非技术公司需要一个人维护下主页），面试中就问问 JS 基础知识。&lt;/p&gt;

&lt;p&gt;你也可能会遇到段位为 9 的面试（比如阿里巴巴和腾讯级别的面试），会被问到算法和数据结构的题目。&lt;/p&gt;

&lt;p&gt;我机智地把段位低的面试放到前面，难度高的面试放到后面。&lt;/p&gt;

&lt;p&gt;就这样，我一点点地增长面试经验，建立自信，并且拿到几个保底 Offer。&lt;/p&gt;

&lt;p&gt;随着面试经验的增加，我也在慢慢地「升级」。我开始能应对高段位的面试了。下面是我得到的 Offer 的统计图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/five-key/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我能回答更难的题目，我拿到更高的薪水，最终，我得到了我想要的工作。&lt;/p&gt;

&lt;h2 id=&#34;忠告三-学好基础知识-因为工作中会用到&#34;&gt;忠告三：学好基础知识，因为工作中会用到&lt;/h2&gt;

&lt;p&gt;你需要不停地学习和为面试做准备。&lt;/p&gt;

&lt;p&gt;为什么？因为如果你不能好好地回答面试官抛出的问题，你就得不到这份工作。&lt;/p&gt;

&lt;p&gt;如果面试官觉得你还没准备好，那么他就不会录用你。&lt;/p&gt;

&lt;p&gt;从 Hacker Reactor 学完之后，我知道我的弱项就是数据结构和算法。我听 &lt;a href=&#34;http://blog.triplebyte.com/bootcamps-vs-college&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;一项统计&lt;/a&gt; 说过，从培训班毕业的人，在数据结构和算法这两项上，比科班毕业生的基础要差一些。&lt;/p&gt;

&lt;p&gt;所以，我坚持每天学习和练习我的弱项。&lt;/p&gt;

&lt;p&gt;我花了几天持续地学习「排序算法」。我还花了几天着重理解计算机网络。&lt;/p&gt;

&lt;p&gt;如果我有一个概念不理解，我就花一整天来看视频教程、在 StackOverflow 上搜答案，直到我搞懂。&lt;/p&gt;

&lt;h2 id=&#34;忠告四-展现你最好的一面&#34;&gt;忠告四：展现你最好的一面&lt;/h2&gt;

&lt;p&gt;进入互联网行业并不简单。不管你有没有准备好，你都必须表现得很好。为了取胜，你必须展现出你最好的一面。&lt;/p&gt;

&lt;h3 id=&#34;推销自己&#34;&gt;推销自己&lt;/h3&gt;

&lt;p&gt;在 Hack Reactor，我们被告知不要主动说明自己没经验。在自我介绍的时候，我们也会不主动提自己在线学习的经历。&lt;/p&gt;

&lt;p&gt;为什么？因为不这样做的话，面试官会马上认为我们是初级开发者，并且给我们打上「没经验」的标签。&lt;/p&gt;

&lt;p&gt;有一次我去一家创业公司面试，当面试官知道我是从在线培训班出来的人之后，直接就走了。还有一家公司因为我的培训经历向我压价，只肯给我 60k 美元的 Offer，比普通初级开发者还低。（译注：不要以为 60k 美元很多，硅谷随便租个单间可能都要每月 1200 美元）&lt;/p&gt;

&lt;p&gt;记住，你要说服面试官你能做好这份工作。&lt;/p&gt;

&lt;p&gt;同时，你要说服你自己，你能做好这份工作。&lt;/p&gt;

&lt;p&gt;你可以跟面试官谈论你对编程的热爱，谈你用 React 和 Node 做过的项目，谈你对 JS 的深刻理解。&lt;/p&gt;

&lt;p&gt;一旦面试官知道了这些，你是不是从培训班里出来的，已经不重要了。&lt;/p&gt;

&lt;p&gt;只有这样，面试官才会录用你。&lt;/p&gt;

&lt;h3 id=&#34;双向选择&#34;&gt;双向选择&lt;/h3&gt;

&lt;p&gt;面试是应聘者和面试官互相了解的过程。&lt;/p&gt;

&lt;p&gt;你要做的就是说服面试官录用你，面试官要做的就是争取到靠谱的人。&lt;/p&gt;

&lt;p&gt;把面试当做你评估你的胜算的过程。把面试当做垫脚石不是一件可耻的事情。&lt;/p&gt;

&lt;p&gt;就算我对一个公司没兴趣，我也会去面试的。&lt;/p&gt;

&lt;p&gt;我会去全国各地面试，只要那个公司邀请我去。我会问面试官问题，从中我了解到了很多新的知识，比如技术团队的结构、他们使用了哪些技术、用到了哪些工具，遇到了哪些挑战，以及他们的系统架构。&lt;/p&gt;

&lt;p&gt;建议你在面试的时候问面试官以下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你们最近遇到了什么技术挑战？&lt;/li&gt;
&lt;li&gt;你在这个公司最满意的一点是什么？&lt;/li&gt;
&lt;li&gt;你们的团队是怎样的结构，工作是怎么分配的？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我把每次面试当做一次学习的机会。每次面试都帮助我提高我的表达能力、面试能力和技术能力。每次面试失败都让我找到我的弱项。&lt;/p&gt;

&lt;h2 id=&#34;忠告五-这是一场马拉松-不是百米赛跑&#34;&gt;忠告五：这是一场马拉松，不是百米赛跑&lt;/h2&gt;

&lt;p&gt;这三个月对我来说绝对不容易。这三个月，我每周都要辛苦六天用于找工作和学习。不过我还是把自己照顾得很好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/five-key/3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有的时候，我会和朋友一起学。有的时候，我会找个咖啡馆自己一个人学，或者去 Hack Reactor 提供的休息室学。每周我还会和教练报告我的进度。&lt;/p&gt;

&lt;p&gt;在这个过程中很容易耗尽热情。那么就吃好，睡好，继续学。&lt;/p&gt;

&lt;p&gt;而且会很容易感到孤单。和一群学友们在一起会好一点。&lt;/p&gt;

&lt;p&gt;建议：要有长期作战的心理准备，照顾好自己的身体。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;联系真人&lt;/li&gt;
&lt;li&gt;由小到大，先易后难&lt;/li&gt;
&lt;li&gt;学好基础知识，因为工作中会用到&lt;/li&gt;
&lt;li&gt;展现你最好的一面&lt;/li&gt;
&lt;li&gt;这是一场马拉松，不是百米赛跑&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你可能觉得找到好工作遥遥无期，但是你会成功的。持续地投入时间、持续地投简历、持续地照顾好自己。&lt;/p&gt;

&lt;p&gt;你会得到你应得的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>this 的值到底是什么？一次说清楚</title>
      <link>http://fangyinghang.com/2016/this-in-js/</link>
      <pubDate>Sun, 20 Nov 2016 13:39:30 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2016/this-in-js/</guid>
      <description>

&lt;p&gt;你可能遇到过这样的 JS 面试题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
  foo: function(){
    console.log(this)
  }
}

var bar = obj.foo
obj.foo() // 打印出的 this 是 obj
bar() // 打印出的 this 是 window
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请解释最后两行函数的值为什么不一样。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;初学者关于 this 的理解一直很模糊。今天这篇文章就要一次讲清楚了。&lt;/p&gt;

&lt;p&gt;而且这个解释，你在别的地方看不到。看懂这篇文章，所有关于 this 的面试题，都是小菜。&lt;/p&gt;

&lt;h2 id=&#34;函数调用&#34;&gt;函数调用&lt;/h2&gt;

&lt;p&gt;首先需要从函数的调用开始讲起。&lt;/p&gt;

&lt;p&gt;JS（ES5）里面有三种函数调用形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func(p1, p2) 
obj.child.method(p1, p2)
func.call(context, p1, p2) // 先不讲 apply
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。&lt;/p&gt;

&lt;p&gt;从看到这篇文章起，你一定要记住，第三种调用形式，才是正常调用形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func.call(context, p1, p2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他两种都是语法糖，可以等价地变为 call 形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func(p1, p2) 等价于
func.call(undefined, p1, p2)

obj.child.method(p1, p2) 等价于
obj.child.method.call(obj.child, p1, p2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请记下来。（我们称此代码为「转换代码」，方便下文引用）&lt;/p&gt;

&lt;p&gt;至此我们的函数调用只有一种形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func.call(context, p1, p2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，this 就好解释了 this，就是上面代码中的 context。就这么简单。&lt;/p&gt;

&lt;p&gt;也就是说 &lt;strong&gt;this 是你 call 一个函数时传的第一个参数&lt;/strong&gt;，
只是由于你从来不用 call 形式的函数调用，所以你一直不知道。&lt;/p&gt;

&lt;h2 id=&#34;func-p1-p2-里的-this&#34;&gt;func(p1, p2) 里的 this&lt;/h2&gt;

&lt;p&gt;先看 func(p1, p2) 中的 this 如何确定：&lt;/p&gt;

&lt;p&gt;当你写下面代码时&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func(){
  console.log(this)
}

func()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等价于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func(){
  console.log(this)
}

func.call(undefined) // 可以简写为 func.call()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则：&lt;/p&gt;

&lt;p&gt;如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）
因此上面的打印结果是 window。&lt;/p&gt;

&lt;p&gt;如果你希望这里的 this 不是 window，很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func.call(obj) // 那么里面的 this 就是 obj 对象了
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;obj-child-method-p1-p2-里的-this&#34;&gt;obj.child.method(p1, p2) 里的 this&lt;/h2&gt;

&lt;p&gt;再看 obj.child.method(p1, p2) 的 this 如何确定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
  foo: function(){
    console.log(this)
  }
}

obj.foo() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照「转换代码」，我们将 obj.foo() 转换为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj.foo.call(obj)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，this 就是 obj。搞定。&lt;/p&gt;

&lt;p&gt;回到题目：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
  foo: function(){
    console.log(this)
  }
}

var bar = obj.foo
obj.foo() // 转换为 obj.foo.call(obj)，this 就是 obj
bar() 
// 转换为 bar.call()
// 由于没有传 context
// 所以 this 就是 undefined
// 最后浏览器给你一个默认的 this —— window 对象
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;语法&#34;&gt;[ ] 语法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function fn (){ console.log(this) }
var arr = [fn, fn2]
arr[0]() // 这里面的 this 又是什么呢？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以把 arr[0]( ) 想象为arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr[0]() 
假想为  arr.0()
然后转换为 arr.0.call(arr)
那么里面的 this 就是 arr 了 :)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;this 就是你 call 一个函数时，传入的第一个参数。（请务必背下来「this 就是 call 的第一个参数」）
如果你的函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式。&lt;/p&gt;

&lt;p&gt;以后你遇到所有跟 this 有关的笔试题，都不会有疑问了。&lt;/p&gt;

&lt;p&gt;完。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JS 中的闭包是什么？</title>
      <link>http://fangyinghang.com/2016/closures-in-js/</link>
      <pubDate>Sun, 18 Sep 2016 01:36:43 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2016/closures-in-js/</guid>
      <description>

&lt;p&gt;大名鼎鼎的闭包！这一题终于来了，面试必问：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;请用自己的话简述&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;什么是「闭包」。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;「闭包」的作用是什么。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;首先来简述什么是闭包&#34;&gt;首先来简述什么是闭包&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/closures-in-js/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假设上面三行代码在一个立即执行函数中（为简明起见，我就不写立即执行函数了，影响读者理解）。&lt;/p&gt;

&lt;p&gt;三行代码中，有一个局部变量 local，有一个函数 foo，foo 里面可以访问到 local 变量。&lt;/p&gt;

&lt;p&gt;好了这就是一个闭包：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;就这么简单。&lt;/p&gt;

&lt;p&gt;有的同学就疑惑了，闭包这么简单么？&lt;/p&gt;

&lt;p&gt;「我听说闭包是需要函数套函数，然后 return 一个函数的呀！」&lt;/p&gt;

&lt;p&gt;比如这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(){
  var local = 1
  function bar(){
    local++
    return local
  }
  return bar
}

var func = foo()
func()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面确实有闭包，local 变量和 bar 函数就组成了一个闭包（Closure）。&lt;/p&gt;

&lt;h3 id=&#34;为什么要函数套函数呢&#34;&gt;为什么要函数套函数呢？&lt;/h3&gt;

&lt;p&gt;是因为需要局部变量，所以才把 local 放在一个函数里，如果不把 local 放在一个函数里，local 就是一个全局变量了，达不到使用闭包的目的——隐藏变量（等会会讲）。&lt;/p&gt;

&lt;p&gt;这也是为什么我上面要说「运行在一个立即执行函数中」。&lt;/p&gt;

&lt;p&gt;有些人看到「闭包」这个名字，就一定觉得要用什么包起来才行。其实这是翻译问题，闭包的原文是 Closure，跟「包」没有任何关系。&lt;/p&gt;

&lt;p&gt;所以函数套函数只是为了造出一个局部变量，跟闭包无关。&lt;/p&gt;

&lt;h3 id=&#34;为什么要-return-bar-呢&#34;&gt;为什么要 return bar 呢？&lt;/h3&gt;

&lt;p&gt;因为如果不 return，你就无法使用这个闭包。把 return bar 改成 window.bar = bar 也是一样的，只要让外面可以访问到这个 bar 函数就行了。&lt;/p&gt;

&lt;p&gt;所以 return bar 只是为了 bar 能被使用，也跟闭包无关。&lt;/p&gt;

&lt;h2 id=&#34;闭包的作用&#34;&gt;闭包的作用&lt;/h2&gt;

&lt;p&gt;闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。&lt;/p&gt;

&lt;p&gt;假设我们在做一个游戏，在写其中关于「还剩几条命」的代码。&lt;/p&gt;

&lt;p&gt;如果不用闭包，你可以直接用一个全局变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.lives = 30 // 还有三十条命
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样看起来很不妥。万一不小心把这个值改成 -1 了怎么办。所以我们不能让别人「直接访问」这个变量。怎么办呢？&lt;/p&gt;

&lt;p&gt;用局部变量。&lt;/p&gt;

&lt;p&gt;但是用局部变量别人又访问不到，怎么办呢？&lt;/p&gt;

&lt;p&gt;暴露一个访问器（函数），让别人可以「间接访问」。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;!function(){
  var lives = 50
  window.奖励一条命 = function(){
    lives += 1
  }
  window.死一条命 = function(){
    lives -= 1
  }
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简明起见，我用了中文 :)&lt;/p&gt;

&lt;p&gt;那么在其他的 JS 文件，就可以使用 window.奖励一条命() 来涨命，使用 window.死一条命() 来让角色掉一条命。&lt;/p&gt;

&lt;p&gt;看到闭包在哪了吗？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/closures-in-js/3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;闭包到底是什么&#34;&gt;闭包到底是什么？&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/closures-in-js/4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;五年前，我也被这个问题困扰，于是去搜了 stackoverflow 并总结下来。你在百度搜闭包，那篇《JavaScript闭包——懂不懂由你，反正我是懂了》就是我写的。当时我还是新手，一直不理解为什么大家口中的闭包这么模糊、这么琢磨不定呢。&lt;/p&gt;

&lt;p&gt;我们重新来审视一下闭包的代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/closures-in-js/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一句是变量声明，第二句是函数声明，第三句是 console.log。&lt;/p&gt;

&lt;p&gt;每一句我都学过，为什么合起来我就看不出来是闭包？&lt;/p&gt;

&lt;p&gt;我告诉你答案，你根本不需要知道闭包这个概念，一样可以使用闭包！&lt;/p&gt;

&lt;p&gt;闭包是 JS 函数作用域的副产品。&lt;/p&gt;

&lt;p&gt;换句话说，正是由于 JS 的函数内部可以使用函数外部的变量，所以这段代码正好符合了闭包的定义。而不是 JS 故意要使用闭包。&lt;/p&gt;

&lt;p&gt;很多编程语言也支持闭包，另外有一些语言则不支持闭包。&lt;/p&gt;

&lt;p&gt;只要你懂了 JS 的作用域，你自然而然就懂了闭包，即使你不知道那就是闭包！&lt;/p&gt;

&lt;h2 id=&#34;所谓闭包的作用&#34;&gt;所谓闭包的作用&lt;/h2&gt;

&lt;p&gt;如果我们在写代码时，根本就不知道闭包，只是按照自己的意图写，最后，发现满足了闭包的定义。&lt;/p&gt;

&lt;p&gt;那么请问，这算是闭包的作用吗？&lt;/p&gt;

&lt;p&gt;这个问题，留给你思考。&lt;/p&gt;

&lt;h2 id=&#34;关于闭包的谣言&#34;&gt;关于闭包的谣言&lt;/h2&gt;

&lt;p&gt;闭包会造成内存泄露？&lt;/p&gt;

&lt;p&gt;错。&lt;/p&gt;

&lt;p&gt;说这话的人根本不知道什么是内存泄露。内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。&lt;/p&gt;

&lt;p&gt;闭包里面的变量明明就是我们需要的变量（lives），凭什么说是内存泄露？&lt;/p&gt;

&lt;p&gt;这个谣言是如何来的？&lt;/p&gt;

&lt;p&gt;因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。&lt;/p&gt;

&lt;p&gt;这是 IE 的问题，不是闭包的问题。参见司徒正美的&lt;a href=&#34;http://www.cnblogs.com/rubylouvre/p/3345294.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;一个小经验&#34;&gt;一个小经验&lt;/h2&gt;

&lt;p&gt;编程界崇尚以简洁优雅为美，很多时候&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你觉得一个概念很复杂，那么很可能是你理解错了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;完。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
