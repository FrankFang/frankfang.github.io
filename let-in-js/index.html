<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="baidu-site-verification" content="npK5sBy52j" />
  <meta name="author" content="方应杭">
  <meta name="description" content="方应杭的个人网站">
  <meta name="keywords" content="方应杭,前端,饥人谷,前端培训">
  
  <link rel="prev" href="http://fangyinghang.com/what-is-npx/" />
  <link rel="next" href="http://fangyinghang.com/why-is-css-so-hard/" />
  <link rel="canonical" href="http://fangyinghang.com/let-in-js/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           我用了两个月的时间才理解 let | 方应杭的个人网站
       
  </title>
  <meta name="title" content="我用了两个月的时间才理解 let | 方应杭的个人网站">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "http://fangyinghang.com/"
    },
    "articleSection" : "posts",
    "name" : "我用了两个月的时间才理解 let",
    "headline" : "我用了两个月的时间才理解 let",
    "description" : "当然不是说用完整的两个月时间来理解 let，而是零零碎碎地理解，同时我还要想着怎么写出一篇文章把这个事情说清楚。
在 let 刚出来的时候，我就「以为」我理解了 let。然鹅在过去的两个月里，我对 let 的理解发生了一波三折的变化。
我写这篇文章，是希望我的学习过程，能对你自学有帮助。
初识 let 跟很多人一样，我第一次了解 let 的特性是从 MDN 的文档：
我得到的信息有这么几条：
 let 声明的变量的作用域是块级的； let 不能重复声明已存在的变量； let 有暂时死区，不会被提升。  大部分人应该都是这么认为的，我也是这么理解的。
这个理解「没有问题」，但是不够「全面和深刻」。
第一次质疑 我第一次质疑我的理解是在遇到 for 循环的时候，代码如下。
// 代码段1 var liList = document.querySelectorAll('li') // 共5个li for( var i=0; i&lt;liList.length; i++){ liList[i].onclick = function(){ console.log(i) } }  大家都知道依次点击 li 会打印出 5 个 5。如果把 var i 改成 let i，就会分别打印出 0、1、2、3、4：
// 代码段2 var liList = document.querySelectorAll('li') // 共5个li for( let i=0; i&lt;liList.",
    "inLanguage" : "zh-CN",
    "author" : "方应杭",
    "creator" : "方应杭",
    "publisher": "方应杭",
    "accountablePerson" : "方应杭",
    "copyrightHolder" : "方应杭",
    "copyrightYear" : "2017",
    "datePublished": "2017-07-27 13:39:30 &#43;0800 CST",
    "dateModified" : "2017-07-27 13:39:30 &#43;0800 CST",
    "url" : "http://fangyinghang.com/let-in-js/",
    "wordCount" : "566",
    "keywords" : [  "方应杭的个人网站"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
          <a href="http://fangyinghang.com/">方应杭的个人网站</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" 
                   
                  href="/search/" title="">
                  搜索
                </a>
                
                <a class="menu-item" 
                   
                  href="/" title="">
                  首页
                </a>
                
                <a class="menu-item" 
                   
                  href="/posts/" title="">
                  文章
                </a>
                
                <a class="menu-item" 
                   
                  href="/contacts/" title="">
                  联系我
                </a>
                
                <a class="menu-item" 
                   
                  href="/wechat-subscribe/" title="">
                  订阅
                </a>
                
                <a class="menu-item" 
                   target="_blank"
                  href="https://www.ximalaya.com/keji/12837765/" title="">
                  电台
                </a>
                
                <a class="menu-item" 
                   
                  href="/index.xml" title="">
                  RSS
                </a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  
              
              <a href="http://fangyinghang.com/">方应杭的个人网站</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/search/" title="">搜索</a>
                
                <a class="menu-item" href="/" title="">首页</a>
                
                <a class="menu-item" href="/posts/" title="">文章</a>
                
                <a class="menu-item" href="/contacts/" title="">联系我</a>
                
                <a class="menu-item" href="/wechat-subscribe/" title="">订阅</a>
                
                <a class="menu-item" href="https://www.ximalaya.com/keji/12837765/" title="">电台</a>
                
                <a class="menu-item" href="/index.xml" title="">RSS</a>
                
        </div>
    </div>
</nav>

    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">我用了两个月的时间才理解 let</h1>
        <div class="post-meta">
                <a itemprop="name" href="http://fangyinghang.com/" rel="author">
                  方应杭</a>
                <span class="post-time">写于
                  <time datetime=2017-07-27 itemprop="datePublished">
                    2017年07月27日
                  </time>
                </span>
                
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        <img src="/images/let-in-js/3.jpg" class="featured_image">
        
        
     
          
          
          

          
          
          

          

<p>当然不是说用完整的两个月时间来理解 let，而是零零碎碎地理解，同时我还要想着怎么写出一篇文章把这个事情说清楚。</p>

<p>在 let 刚出来的时候，我就「以为」我理解了 let。然鹅在过去的两个月里，我对 let 的理解发生了一波三折的变化。</p>

<p>我写这篇文章，是希望我的学习过程，能对你自学有帮助。</p>

<h2 id="初识-let">初识 let</h2>

<p>跟很多人一样，我第一次了解 let 的特性是从 MDN 的文档：</p>

<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/let-in-js/1.jpg" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure></p>

<p>我得到的信息有这么几条：</p>

<ul>
<li>let 声明的变量的作用域是块级的；</li>
<li>let 不能重复声明已存在的变量；</li>
<li>let 有暂时死区，不会被提升。</li>
</ul>

<p>大部分人应该都是这么认为的，我也是这么理解的。</p>

<p>这个理解「没有问题」，但是不够「全面和深刻」。</p>

<h2 id="第一次质疑">第一次质疑</h2>

<p>我第一次质疑我的理解是在遇到 for 循环的时候，代码如下。</p>

<pre><code>// 代码段1
var liList = document.querySelectorAll('li') // 共5个li
for( var i=0; i&lt;liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
</code></pre>

<p>大家都知道依次点击 li 会打印出 5 个 5。如果把 var i 改成 let i，就会分别打印出 0、1、2、3、4：</p>

<pre><code>// 代码段2
var liList = document.querySelectorAll('li') // 共5个li
for( let i=0; i&lt;liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
</code></pre>

<p>然而，用我之前的知识来理解这个代码是不能自圆其说的。因为代码中依然只声明了一个 i，在 for 循环结束后，i 的值还是会变成 5 才对。</p>

<p>这说明我的理解有误。</p>

<p>于是我去看 MDN 的例子，发现鸡贼的 MDN 巧妙地避开了这个问题，它的例子是这样的：</p>

<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/let-in-js/2.jpg" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure></p>

<p>你看 MDN 的例子，在每次循环的时候用 let j 保留的 i 的值，所以在 i 变化的时候，j 并不会变化。而console.log 的是 j，所以不会出现 5 个 5。</p>

<p><strong>为什么 MDN 要故意声明一个 j 呢，为什么不直接用 i 呢？</strong></p>

<p>我猜测 MDN 为了简化知识，隐瞒了什么。</p>

<p>于是我去看了看 ES 文档，其中的 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement-runtime-semantics-labelledevaluation" rel="nofollow noreferrer" target="_blank">13.7.4.7 章节</a>
清楚地说明了个中缘由，但是由于说得太清楚了，很多人都看不下去，不信你可以试试。</p>

<p>我说一下我的理解：</p>

<ol>
<li><code>for( let i = 0; i&lt; 5; i++)</code> 这句话的圆括号之间，有一个隐藏的作用域</li>
<li><code>for( let i = 0; i&lt; 5; i++) { 循环体 }</code> 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。</li>
<li>其他细节就不说了，太细碎了</li>
</ol>

<p>也就是说上面的代码段2可以近似近似近似地理解为</p>

<pre><code>// 代码段3
var liList = document.querySelectorAll('li') // 共5个li
for( let i=0; i&lt;liList.length; i++){
  let i = 隐藏作用域中的i // 看这里看这里看这里
  liList[i].onclick = function(){
    console.log(i)
  }
}
</code></pre>

<p>那样的话，5 次循环，就会有 5 个不同的 i，console.log 出来的 i 当然也是不同的值。</p>

<p>再加上隐藏作用域里的 i，一共有 6 个 i。</p>

<p>这就是 MDN 加那句 <code>let j = i</code> 的原因：方便新人理解。</p>

<p>总得来说就是 let/const 在与 for 一起用时，会有一个 perIterationBindings 的概念（一种语法糖）。</p>

<p>从此之后，我就开始怀疑我对 let 的所有理解了。</p>

<h2 id="第二次质疑">第二次质疑</h2>

<p>我在 StackOverflow 上闲逛的时候，无意中发现了一个是关于「let 到底有没有提升」的问题：</p>

<blockquote>
<p><a href="https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6" rel="nofollow noreferrer" target="_blank">Are variables declared with let or const not hoisted in ES6?</a></p>
</blockquote>

<p>其中一个高票回答认为 JS 中所有的声明（var/let/const/function/class），都存在提升，理由是如下代码：</p>

<pre><code>x = &quot;global&quot;;
// function scope:
(function() {
    x; // not &quot;global&quot;

    var/let/… x;
}());
// block scope (not for `var`s):
{
    x; // not &quot;global&quot;

    let/const/… x;
}
</code></pre>

<p>我觉得他说得挺有道理的。于是我又去 MDN 和 ECMAScript 翻了翻，发现两处疑点：</p>

<ol>
<li>MDN 关于 let 是否存在提升的章节，被编辑了两次，第一次说存在提升，第二次说不存在提升（参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let%24compare?locale=en-US&amp;to=1242757&amp;from=1242229" rel="nofollow noreferrer" target="_blank">2017 年 3 月 10 号的变更记录</a>）。也就是说 MDN 的维护者都在这个问题上产生过分歧，更何况我们了。</li>
<li>ES 文档里出现了「var/let hoisting」字样。</li>
</ol>

<p>鉴于此，我认为应该尊重 ES 文档，认为 let 确实存在提升。只不过由于暂时死区的限制，你不能在 let x 之前使用 let（详见我的那篇 let 声明会提升（hoist）吗？）。</p>

<h2 id="故事并没有结束">故事并没有结束</h2>

<p>当一个疑问一直存在你脑中时，你会在潜意识中不停地对它进行消化和思考。</p>

<p>上面说到我认为 let 存在提升的主要原因是 ES 文档中出现了「var/let hoisting」字样。</p>

<p>但是我在咨询 TC39 的成员 <a href="https://twitter.com/rwaldron" rel="nofollow noreferrer" target="_blank">Rick Waldron</a> 时，他是这么说的：</p>

<blockquote>
<p>You&rsquo;re misunderstanding the intention of that (non-normative) Note. let and const do not hoist as var and function decls do.</p>
</blockquote>

<p>而且还细心地专门写了一个 <a href="https://gist.github.com/rwaldron/ca35924d59ddc60a6aa165e1e4a3acda" rel="nofollow noreferrer" target="_blank">gist</a> 来详细解释（twitter 有 140 字限制）。</p>

<p>既然 TC39 的 representative 都说了 let hoisting 不是一个正式词汇，那我就应该重新思考一下什么是「提升」了。</p>

<p>于是就有了这篇文章，我想要说一下我对「提升」的理解。你看完之后，就知道 let 到底有没有「提升」。</p>

<p><strong>首先明确一点：提升不是一个技术名词。</strong></p>

<p>要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」</p>

<p>有的地方把创建说成是声明（declare），为了将这个概念与变量声明区别开，我故意不使用声明这个字眼。</p>

<p>有的地方把初始化叫做绑定（binding），但我感觉这个词不如初始化形象。</p>

<h2 id="创建-初始化和赋值">创建、初始化和赋值</h2>

<h3 id="我们来看看-var-声明的-创建-初始化和赋值-过程">我们来看看 var 声明的「创建、初始化和赋值」过程</h3>

<p>假设有如下代码：</p>

<pre><code>function fn(){
  var x = 1
  var y = 2
}
fn()
</code></pre>

<p>在执行 fn 时，会有以下过程（不完全）：</p>

<ol>
<li>进入 fn，为 fn 创建一个环境。</li>
<li>找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。</li>
<li>将这些变量「初始化」为 undefined。</li>
<li>开始执行代码</li>
<li>x = 1 将 x 变量「赋值」为 1</li>
<li>y = 2 将 y 变量「赋值」为 2</li>
</ol>

<p>也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。</p>

<p>这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。</p>

<h3 id="接下来来看-function-声明的-创建-初始化和赋值-过程">接下来来看 function 声明的「创建、初始化和赋值」过程</h3>

<p>假设代码如下：</p>

<pre><code>fn2()

function fn2(){
  console.log(2)
}
</code></pre>

<p>JS 引擎会有以下过程：</p>

<ol>
<li>找到所有用 function 声明的变量，在环境中「创建」这些变量。</li>
<li>将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。</li>
<li>开始执行代码 fn2()</li>
</ol>

<p>也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」。</p>

<h3 id="接下来看-let-声明的-创建-初始化和赋值-过程">接下来看 let 声明的「创建、初始化和赋值」过程</h3>

<p>假设代码如下：</p>

<pre><code>{
  let x = 1
  x = 2
}
</code></pre>

<p>我们只看 {} 里面的过程：</p>

<ol>
<li>找到所有用 let 声明的变量，在环境中「创建」这些变量</li>
<li>开始执行代码（注意现在还没有初始化）</li>
<li>执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）</li>
<li>执行 x = 2，对 x 进行「赋值」</li>
</ol>

<p>这就解释了为什么在 let x 之前使用 x 会报错：</p>

<pre><code>let x = 'global'
{
  console.log(x) // Uncaught ReferenceError: x is not defined
  let x = 1
}
</code></pre>

<p>原因有两个</p>

<ol>
<li>console.log(x) 中的 x 指的是下面的 x，而不是全局的 x</li>
<li>执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）</li>
</ol>

<p>看到这里，你应该明白了 let 到底有没有提升：</p>

<ol>
<li>let 的「创建」过程被提升了，但是初始化没有提升。</li>
<li>var 的「创建」和「初始化」都被提升了。</li>
<li>function 的「创建」「初始化」和「赋值」都被提升了。</li>
</ol>

<p>最后看 const，其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程。</p>

<p>这四种声明，用下图就可以快速理解：</p>

<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/let-in-js/3.jpg" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure></p>

<p>所谓暂时死区，就是<strong>不能在初始化之前，使用变量</strong>。</p>

<h2 id="完了吗">完了吗？</h2>

<p>故事依然没有结束，这周我在知乎上<a href="https://www.zhihu.com/question/62966713" rel="nofollow noreferrer" target="_blank">问了一个问题</a></p>

<blockquote>
<p>如何理解 let x = x 报错之后，再次 let x 依然会报错？</p>
</blockquote>

<p>这个问题是饥人谷的学生问我的。</p>

<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/let-in-js/4.png" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure></p>

<p>这个问题说明：如果 let x 的初始化过程失败了，那么</p>

<ol>
<li>x 变量就将永远处于 created 状态。</li>
<li>你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。</li>
<li>由于 x 无法被初始化，所以 x 永远处在暂时死区（也就是盗梦空间里的 limbo）！</li>
<li>有人会觉得 JS 坑，怎么能出现这种情况；其实问题不大，因为此时代码已经报错了，后面的代码想执行也没机会。</li>
</ol>

<p>细节参见我的另一篇文章《<a href="https://zhuanlan.zhihu.com/p/28117094" rel="nofollow noreferrer" target="_blank">JS变量封禁大法：薛定谔的X</a>》</p>

<p>以上，就是一个 let 引发的思考。</p>

<p>重要参考：<a href="https://dmitripavlutin.com/variables-lifecycle-and-why-let-is-not-hoisted/" rel="nofollow noreferrer" target="_blank">JavaScript variables lifecycle: why let is not hoisted</a></p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>作者</span>
                <span>方应杭 </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>链接</span>
                    <a href=http://fangyinghang.com/let-in-js/>http://fangyinghang.com/let-in-js/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">后退</a></span> · 
                <span><a href="http://fangyinghang.com/">回到首页</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="http://fangyinghang.com/what-is-npx/" class="prev" rel="prev" title="npx 是干什么的"><i class="iconfont icon-left"></i>&nbsp;npx 是干什么的</a>
         
        
        <a href="http://fangyinghang.com/why-is-css-so-hard/" class="next" rel="next" title="CSS 为什么这么难学">CSS 为什么这么难学&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
  <div class="copyright">
    <div>
      &copy;
      
      <span itemprop="copyrightYear">2012 - 2018</span>
      
      <span class="with-love">
        <i class="iconfont icon-love"></i> 
      </span>
      
      <span class="author" itemprop="copyrightHolder"><a href="http://fangyinghang.com/">方应杭</a> </span> 
      

      
      <span>
    </div>
    <div>
      Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
  </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  




     </div>
  </body>
</html>
