<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 方应杭的个人网站</title>
    <link>http://fangyinghang.com/posts/</link>
    <description>Recent content in Posts on 方应杭的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 15 Oct 2018 16:22:04 +0800</lastBuildDate>
    
	<atom:link href="http://fangyinghang.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>jQuery 都过时了，那我还学它干嘛？</title>
      <link>http://fangyinghang.com/2018/why-still-jquery/</link>
      <pubDate>Mon, 15 Oct 2018 16:22:04 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2018/why-still-jquery/</guid>
      <description>今天饥人谷的新生问我
 请问现在我还需要学习 jQuery 吗？听你在知乎说 jQuery 已经过时了，是不是就不用学了？
 短答案 jQuery 还是可以学一学的，学了之后对写代码和封装库很有帮助。
现在的「新人」依然可以学习 jQuery 的思想，因为以「新人」的水平，直接理解 Vue / React 的思想难度较大，jQuery 是一个很不错的中间过渡，因为 jQuery 也蕴含了非常多的编程套路。
但是如果你不想学，就不学吧。直接去学 Vue / React 会难一点，但也能学会。
长答案： jQuery 当然过时了。
距离我上次在项目中使用 jQuery，可能已经快两年时间了（除去上课时演示功能时用 jQuery）。回想我学习 jQuery 的过程，还挺神奇的。
当年我在大学的技术小组里做 C# 网站开发，需要用到 jQuery 特效，组里的一名小伙伴会用一点 jQuery，很快就用 .animate 做出了让我啧啧称奇的特效。我觉得 jQuery 好神奇啊，虽然我当时连 JS 都不会。
于是我立马买了一本《锋利的 jQuery》，硬看。
什么叫「硬看」呢？因为我不会 JS，而且我并没有照着书上敲代码，仅仅使用眼睛「看 jQuery 代码」。神奇的是——我居然很快看懂了几乎整本书。以至于那位会用 jQuery 的小伙伴遇到 bug 问我时我能直接给出解答，看起来他并没有看《锋利的 jQuery》这本书（笑）。
到了 2018 年，几乎已经没有新项目会使用 jQuery 来开发了；即使有，也是一件不值得拿出来炫耀的事情。那为什么我还是建议学习 jQuery 呢？
原因如下。
jQuery 教你如何设计 API 上文说到我一个不会 JS 的人居然能看懂 jQuery 的书，其实这不是因为我厉害，而是因为 jQuery 的 API 设计得太人性化了！</description>
    </item>
    
    <item>
      <title>我用了两个月的时间才理解 let</title>
      <link>http://fangyinghang.com/2017/let-in-js/</link>
      <pubDate>Thu, 27 Jul 2017 13:39:30 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2017/let-in-js/</guid>
      <description>当然不是说用完整的两个月时间来理解 let，而是零零碎碎地理解，同时我还要想着怎么写出一篇文章把这个事情说清楚。
在 let 刚出来的时候，我就「以为」我理解了 let。然鹅在过去的两个月里，我对 let 的理解发生了一波三折的变化。
我写这篇文章，是希望我的学习过程，能对你自学有帮助。
初识 let 跟很多人一样，我第一次了解 let 的特性是从 MDN 的文档：
我得到的信息有这么几条：
 let 声明的变量的作用域是块级的； let 不能重复声明已存在的变量； let 有暂时死区，不会被提升。  大部分人应该都是这么认为的，我也是这么理解的。
这个理解「没有问题」，但是不够「全面和深刻」。
第一次质疑 我第一次质疑我的理解是在遇到 for 循环的时候，代码如下。
// 代码段1 var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li for( var i=0; i&amp;lt;liList.length; i++){ liList[i].onclick = function(){ console.log(i) } }  大家都知道依次点击 li 会打印出 5 个 5。如果把 var i 改成 let i，就会分别打印出 0、1、2、3、4：
// 代码段2 var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li for( let i=0; i&amp;lt;liList.</description>
    </item>
    
    <item>
      <title>this 的值到底是什么？一次说清楚</title>
      <link>http://fangyinghang.com/2016/this-in-js/</link>
      <pubDate>Sun, 20 Nov 2016 13:39:30 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2016/this-in-js/</guid>
      <description>你可能遇到过这样的 JS 面试题：
var obj = { foo: function(){ console.log(this) } } var bar = obj.foo obj.foo() // 打印出的 this 是 obj bar() // 打印出的 this 是 window  请解释最后两行函数的值为什么不一样。
初学者关于 this 的理解一直很模糊。今天这篇文章就要一次讲清楚了。
而且这个解释，你在别的地方看不到。看懂这篇文章，所有关于 this 的面试题，都是小菜。
函数调用 首先需要从函数的调用开始讲起。
JS（ES5）里面有三种函数调用形式：
func(p1, p2) obj.child.method(p1, p2) func.call(context, p1, p2) // 先不讲 apply  一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。
从看到这篇文章起，你一定要记住，第三种调用形式，才是正常调用形式：
func.call(context, p1, p2)  其他两种都是语法糖，可以等价地变为 call 形式：
func(p1, p2) 等价于 func.call(undefined, p1, p2) obj.child.method(p1, p2) 等价于 obj.child.method.call(obj.child, p1, p2)  请记下来。（我们称此代码为「转换代码」，方便下文引用）</description>
    </item>
    
  </channel>
</rss>