<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>方应杭的个人网站 on 方应杭的个人网站</title>
    <link>http://fangyinghang.com/</link>
    <description>Recent content in 方应杭的个人网站 on 方应杭的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 08 Nov 2018 04:04:02 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>我的课程</title>
      <link>http://fangyinghang.com/my/courses/</link>
      <pubDate>Thu, 08 Nov 2018 04:04:02 +0800</pubDate>
      
      <guid>http://fangyinghang.com/my/courses/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/63308031-98f4-4907-ade4-c22d4aa82f27&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;React 入门（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/6f105ef5-8969-4863-82e7-beb162ddc5b3&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;TypeScript 入门（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/9ff75915-a19f-451d-b3a5-85feed5a6bc1&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;SCSS 入门（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/6d63da67-6eea-4711-aeb4-0c3a949341dc&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;自制 Vue UI 框架（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/24f54465-854f-4de7-9808-72a0bf5b3181&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS 深入浅出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/12a78a03-35f9-42ea-9b37-540540460f6e&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ES6 深入浅出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/003b1951-22af-4821-ad80-d2880c0074eb&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;CSS 深入浅出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/ec3a5e28-02da-47d6-9226-927db23e82a2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;前端零基础入门&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>经历</title>
      <link>http://fangyinghang.com/my/resume/</link>
      <pubDate>Thu, 08 Nov 2018 04:04:02 +0800</pubDate>
      
      <guid>http://fangyinghang.com/my/resume/</guid>
      <description>&lt;p&gt;毕业于华中科技大学软件工程专业，先后在腾讯、阿里巴巴、彩程担任前端工程师。
现在在 &lt;a href=&#34;https://jirengu.com&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;饥人谷&lt;/a&gt; 讲课、开发、写作。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;技术栈&#34;&gt;技术栈&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Web 前端开发技术（CSS、JavaScript、TypeScript、Vue、React、Angular 等）&lt;/li&gt;
&lt;li&gt;Web 后端开发技术（Ruby on Rails、Node.js 等）&lt;/li&gt;
&lt;li&gt;正在学习 Kotlin、Swift&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;工具箱&#34;&gt;工具箱&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;编辑器喜欢用 vim、WebStorm、RubyMine，&lt;a href=&#34;https://jscode.me/t/topic/851&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;vim 配置&lt;/a&gt; 还挺简洁的。&lt;/li&gt;
&lt;li&gt;在 iTerm2.app + zshell 里运行命令行&lt;/li&gt;
&lt;li&gt;使用 Paste.app 管理剪切板&lt;/li&gt;
&lt;li&gt;使用 xScope + Sip + Sketch 切图&lt;/li&gt;
&lt;li&gt;使用印象笔记管理知识&lt;/li&gt;
&lt;li&gt;使用 The Hit List.app + Tower.im 管理工作任务&lt;/li&gt;
&lt;li&gt;讲课时非常喜欢用 &lt;a href=&#34;https://detail.tmall.com/item.htm?id=17866298588&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Wacom 数位板&lt;/a&gt; 演示思路&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>微信订阅</title>
      <link>http://fangyinghang.com/wechat-subscribe/</link>
      <pubDate>Thu, 08 Nov 2018 03:43:41 +0800</pubDate>
      
      <guid>http://fangyinghang.com/wechat-subscribe/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/me/qrcode.jpg&#34; alt=&#34;扫码关注&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>联系方式</title>
      <link>http://fangyinghang.com/contacts/</link>
      <pubDate>Thu, 08 Nov 2018 03:43:41 +0800</pubDate>
      
      <guid>http://fangyinghang.com/contacts/</guid>
      <description>&lt;p&gt;邮箱：fangyinghang # foxmail.com&lt;/p&gt;

&lt;p&gt;微信： &lt;img src=&#34;http://fangyinghang.com/images/me/wechat.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我用了两个月的时间才理解 let</title>
      <link>http://fangyinghang.com/2017/let-in-js/</link>
      <pubDate>Thu, 27 Jul 2017 13:39:30 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2017/let-in-js/</guid>
      <description>

&lt;p&gt;当然不是说用完整的两个月时间来理解 let，而是零零碎碎地理解，同时我还要想着怎么写出一篇文章把这个事情说清楚。&lt;/p&gt;

&lt;p&gt;在 let 刚出来的时候，我就「以为」我理解了 let。然鹅在过去的两个月里，我对 let 的理解发生了一波三折的变化。&lt;/p&gt;

&lt;p&gt;我写这篇文章，是希望我的学习过程，能对你自学有帮助。&lt;/p&gt;

&lt;h2 id=&#34;初识-let&#34;&gt;初识 let&lt;/h2&gt;

&lt;p&gt;跟很多人一样，我第一次了解 let 的特性是从 MDN 的文档：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我得到的信息有这么几条：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;let 声明的变量的作用域是块级的；&lt;/li&gt;
&lt;li&gt;let 不能重复声明已存在的变量；&lt;/li&gt;
&lt;li&gt;let 有暂时死区，不会被提升。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大部分人应该都是这么认为的，我也是这么理解的。&lt;/p&gt;

&lt;p&gt;这个理解「没有问题」，但是不够「全面和深刻」。&lt;/p&gt;

&lt;h2 id=&#34;第一次质疑&#34;&gt;第一次质疑&lt;/h2&gt;

&lt;p&gt;我第一次质疑我的理解是在遇到 for 循环的时候，代码如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代码段1
var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li
for( var i=0; i&amp;lt;liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家都知道依次点击 li 会打印出 5 个 5。如果把 var i 改成 let i，就会分别打印出 0、1、2、3、4：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代码段2
var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li
for( let i=0; i&amp;lt;liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，用我之前的知识来理解这个代码是不能自圆其说的。因为代码中依然只声明了一个 i，在 for 循环结束后，i 的值还是会变成 5 才对。&lt;/p&gt;

&lt;p&gt;这说明我的理解有误。&lt;/p&gt;

&lt;p&gt;于是我去看 MDN 的例子，发现鸡贼的 MDN 巧妙地避开了这个问题，它的例子是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;你看 MDN 的例子，在每次循环的时候用 let j 保留的 i 的值，所以在 i 变化的时候，j 并不会变化。而console.log 的是 j，所以不会出现 5 个 5。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么 MDN 要故意声明一个 j 呢，为什么不直接用 i 呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我猜测 MDN 为了简化知识，隐瞒了什么。&lt;/p&gt;

&lt;p&gt;于是我去看了看 ES 文档，其中的 &lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement-runtime-semantics-labelledevaluation&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;13.7.4.7 章节&lt;/a&gt;
清楚地说明了个中缘由，但是由于说得太清楚了，很多人都看不下去，不信你可以试试。&lt;/p&gt;

&lt;p&gt;我说一下我的理解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;for( let i = 0; i&amp;lt; 5; i++)&lt;/code&gt; 这句话的圆括号之间，有一个隐藏的作用域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for( let i = 0; i&amp;lt; 5; i++) { 循环体 }&lt;/code&gt; 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。&lt;/li&gt;
&lt;li&gt;其他细节就不说了，太细碎了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说上面的代码段2可以近似近似近似地理解为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代码段3
var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li
for( let i=0; i&amp;lt;liList.length; i++){
  let i = 隐藏作用域中的i // 看这里看这里看这里
  liList[i].onclick = function(){
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那样的话，5 次循环，就会有 5 个不同的 i，console.log 出来的 i 当然也是不同的值。&lt;/p&gt;

&lt;p&gt;再加上隐藏作用域里的 i，一共有 6 个 i。&lt;/p&gt;

&lt;p&gt;这就是 MDN 加那句 &lt;code&gt;let j = i&lt;/code&gt; 的原因：方便新人理解。&lt;/p&gt;

&lt;p&gt;总得来说就是 let/const 在与 for 一起用时，会有一个 perIterationBindings 的概念（一种语法糖）。&lt;/p&gt;

&lt;p&gt;从此之后，我就开始怀疑我对 let 的所有理解了。&lt;/p&gt;

&lt;h2 id=&#34;第二次质疑&#34;&gt;第二次质疑&lt;/h2&gt;

&lt;p&gt;我在 StackOverflow 上闲逛的时候，无意中发现了一个是关于「let 到底有没有提升」的问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Are variables declared with let or const not hoisted in ES6?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中一个高票回答认为 JS 中所有的声明（var/let/const/function/class），都存在提升，理由是如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = &amp;quot;global&amp;quot;;
// function scope:
(function() {
    x; // not &amp;quot;global&amp;quot;

    var/let/… x;
}());
// block scope (not for `var`s):
{
    x; // not &amp;quot;global&amp;quot;

    let/const/… x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我觉得他说得挺有道理的。于是我又去 MDN 和 ECMAScript 翻了翻，发现两处疑点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MDN 关于 let 是否存在提升的章节，被编辑了两次，第一次说存在提升，第二次说不存在提升（参考 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let%24compare?locale=en-US&amp;amp;to=1242757&amp;amp;from=1242229&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;2017 年 3 月 10 号的变更记录&lt;/a&gt;）。也就是说 MDN 的维护者都在这个问题上产生过分歧，更何况我们了。&lt;/li&gt;
&lt;li&gt;ES 文档里出现了「var/let hoisting」字样。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;鉴于此，我认为应该尊重 ES 文档，认为 let 确实存在提升。只不过由于暂时死区的限制，你不能在 let x 之前使用 let（详见我的那篇 let 声明会提升（hoist）吗？）。&lt;/p&gt;

&lt;h2 id=&#34;故事并没有结束&#34;&gt;故事并没有结束&lt;/h2&gt;

&lt;p&gt;当一个疑问一直存在你脑中时，你会在潜意识中不停地对它进行消化和思考。&lt;/p&gt;

&lt;p&gt;上面说到我认为 let 存在提升的主要原因是 ES 文档中出现了「var/let hoisting」字样。&lt;/p&gt;

&lt;p&gt;但是我在咨询 TC39 的成员 &lt;a href=&#34;https://twitter.com/rwaldron&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Rick Waldron&lt;/a&gt; 时，他是这么说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You&amp;rsquo;re misunderstanding the intention of that (non-normative) Note. let and const do not hoist as var and function decls do.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而且还细心地专门写了一个 &lt;a href=&#34;https://gist.github.com/rwaldron/ca35924d59ddc60a6aa165e1e4a3acda&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;gist&lt;/a&gt; 来详细解释（twitter 有 140 字限制）。&lt;/p&gt;

&lt;p&gt;既然 TC39 的 representative 都说了 let hoisting 不是一个正式词汇，那我就应该重新思考一下什么是「提升」了。&lt;/p&gt;

&lt;p&gt;于是就有了这篇文章，我想要说一下我对「提升」的理解。你看完之后，就知道 let 到底有没有「提升」。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先明确一点：提升不是一个技术名词。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」&lt;/p&gt;

&lt;p&gt;有的地方把创建说成是声明（declare），为了将这个概念与变量声明区别开，我故意不使用声明这个字眼。&lt;/p&gt;

&lt;p&gt;有的地方把初始化叫做绑定（binding），但我感觉这个词不如初始化形象。&lt;/p&gt;

&lt;h2 id=&#34;创建-初始化和赋值&#34;&gt;创建、初始化和赋值&lt;/h2&gt;

&lt;h3 id=&#34;我们来看看-var-声明的-创建-初始化和赋值-过程&#34;&gt;我们来看看 var 声明的「创建、初始化和赋值」过程&lt;/h3&gt;

&lt;p&gt;假设有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fn(){
  var x = 1
  var y = 2
}
fn()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在执行 fn 时，会有以下过程（不完全）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;进入 fn，为 fn 创建一个环境。&lt;/li&gt;
&lt;li&gt;找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。&lt;/li&gt;
&lt;li&gt;将这些变量「初始化」为 undefined。&lt;/li&gt;
&lt;li&gt;开始执行代码&lt;/li&gt;
&lt;li&gt;x = 1 将 x 变量「赋值」为 1&lt;/li&gt;
&lt;li&gt;y = 2 将 y 变量「赋值」为 2&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。&lt;/p&gt;

&lt;p&gt;这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。&lt;/p&gt;

&lt;h3 id=&#34;接下来来看-function-声明的-创建-初始化和赋值-过程&#34;&gt;接下来来看 function 声明的「创建、初始化和赋值」过程&lt;/h3&gt;

&lt;p&gt;假设代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn2()

function fn2(){
  console.log(2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JS 引擎会有以下过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找到所有用 function 声明的变量，在环境中「创建」这些变量。&lt;/li&gt;
&lt;li&gt;将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。&lt;/li&gt;
&lt;li&gt;开始执行代码 fn2()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」。&lt;/p&gt;

&lt;h3 id=&#34;接下来看-let-声明的-创建-初始化和赋值-过程&#34;&gt;接下来看 let 声明的「创建、初始化和赋值」过程&lt;/h3&gt;

&lt;p&gt;假设代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  let x = 1
  x = 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只看 {} 里面的过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找到所有用 let 声明的变量，在环境中「创建」这些变量&lt;/li&gt;
&lt;li&gt;开始执行代码（注意现在还没有初始化）&lt;/li&gt;
&lt;li&gt;执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）&lt;/li&gt;
&lt;li&gt;执行 x = 2，对 x 进行「赋值」&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就解释了为什么在 let x 之前使用 x 会报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = &#39;global&#39;
{
  console.log(x) // Uncaught ReferenceError: x is not defined
  let x = 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因有两个&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;console.log(x) 中的 x 指的是下面的 x，而不是全局的 x&lt;/li&gt;
&lt;li&gt;执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看到这里，你应该明白了 let 到底有没有提升：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;let 的「创建」过程被提升了，但是初始化没有提升。&lt;/li&gt;
&lt;li&gt;var 的「创建」和「初始化」都被提升了。&lt;/li&gt;
&lt;li&gt;function 的「创建」「初始化」和「赋值」都被提升了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后看 const，其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程。&lt;/p&gt;

&lt;p&gt;这四种声明，用下图就可以快速理解：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所谓暂时死区，就是&lt;strong&gt;不能在初始化之前，使用变量&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;完了吗&#34;&gt;完了吗？&lt;/h2&gt;

&lt;p&gt;故事依然没有结束，这周我在知乎上&lt;a href=&#34;https://www.zhihu.com/question/62966713&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;问了一个问题&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如何理解 let x = x 报错之后，再次 let x 依然会报错？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个问题是饥人谷的学生问我的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个问题说明：如果 let x 的初始化过程失败了，那么&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;x 变量就将永远处于 created 状态。&lt;/li&gt;
&lt;li&gt;你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。&lt;/li&gt;
&lt;li&gt;由于 x 无法被初始化，所以 x 永远处在暂时死区（也就是盗梦空间里的 limbo）！&lt;/li&gt;
&lt;li&gt;有人会觉得 JS 坑，怎么能出现这种情况；其实问题不大，因为此时代码已经报错了，后面的代码想执行也没机会。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;细节参见我的另一篇文章《&lt;a href=&#34;https://zhuanlan.zhihu.com/p/28117094&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS变量封禁大法：薛定谔的X&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;以上，就是一个 let 引发的思考。&lt;/p&gt;

&lt;p&gt;重要参考：&lt;a href=&#34;https://dmitripavlutin.com/variables-lifecycle-and-why-let-is-not-hoisted/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JavaScript variables lifecycle: why let is not hoisted&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>this 的值到底是什么？一次说清楚</title>
      <link>http://fangyinghang.com/2016/this-in-js/</link>
      <pubDate>Sun, 20 Nov 2016 13:39:30 +0800</pubDate>
      
      <guid>http://fangyinghang.com/2016/this-in-js/</guid>
      <description>

&lt;p&gt;你可能遇到过这样的 JS 面试题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
  foo: function(){
    console.log(this)
  }
}

var bar = obj.foo
obj.foo() // 打印出的 this 是 obj
bar() // 打印出的 this 是 window
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请解释最后两行函数的值为什么不一样。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;初学者关于 this 的理解一直很模糊。今天这篇文章就要一次讲清楚了。&lt;/p&gt;

&lt;p&gt;而且这个解释，你在别的地方看不到。看懂这篇文章，所有关于 this 的面试题，都是小菜。&lt;/p&gt;

&lt;h2 id=&#34;函数调用&#34;&gt;函数调用&lt;/h2&gt;

&lt;p&gt;首先需要从函数的调用开始讲起。&lt;/p&gt;

&lt;p&gt;JS（ES5）里面有三种函数调用形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func(p1, p2) 
obj.child.method(p1, p2)
func.call(context, p1, p2) // 先不讲 apply
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。&lt;/p&gt;

&lt;p&gt;从看到这篇文章起，你一定要记住，第三种调用形式，才是正常调用形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func.call(context, p1, p2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他两种都是语法糖，可以等价地变为 call 形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func(p1, p2) 等价于
func.call(undefined, p1, p2)

obj.child.method(p1, p2) 等价于
obj.child.method.call(obj.child, p1, p2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请记下来。（我们称此代码为「转换代码」，方便下文引用）&lt;/p&gt;

&lt;p&gt;至此我们的函数调用只有一种形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func.call(context, p1, p2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，this 就好解释了 this，就是上面代码中的 context。就这么简单。&lt;/p&gt;

&lt;p&gt;也就是说 &lt;strong&gt;this 是你 call 一个函数时传的第一个参数&lt;/strong&gt;，
只是由于你从来不用 call 形式的函数调用，所以你一直不知道。&lt;/p&gt;

&lt;h2 id=&#34;func-p1-p2-里的-this&#34;&gt;func(p1, p2) 里的 this&lt;/h2&gt;

&lt;p&gt;先看 func(p1, p2) 中的 this 如何确定：&lt;/p&gt;

&lt;p&gt;当你写下面代码时&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func(){
  console.log(this)
}

func()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等价于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func(){
  console.log(this)
}

func.call(undefined) // 可以简写为 func.call()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则：&lt;/p&gt;

&lt;p&gt;如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）
因此上面的打印结果是 window。&lt;/p&gt;

&lt;p&gt;如果你希望这里的 this 不是 window，很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func.call(obj) // 那么里面的 this 就是 obj 对象了
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;obj-child-method-p1-p2-里的-this&#34;&gt;obj.child.method(p1, p2) 里的 this&lt;/h2&gt;

&lt;p&gt;再看 obj.child.method(p1, p2) 的 this 如何确定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
  foo: function(){
    console.log(this)
  }
}

obj.foo() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照「转换代码」，我们将 obj.foo() 转换为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj.foo.call(obj)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，this 就是 obj。搞定。&lt;/p&gt;

&lt;p&gt;回到题目：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
  foo: function(){
    console.log(this)
  }
}

var bar = obj.foo
obj.foo() // 转换为 obj.foo.call(obj)，this 就是 obj
bar() 
// 转换为 bar.call()
// 由于没有传 context
// 所以 this 就是 undefined
// 最后浏览器给你一个默认的 this —— window 对象
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;语法&#34;&gt;[ ] 语法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function fn (){ console.log(this) }
var arr = [fn, fn2]
arr[0]() // 这里面的 this 又是什么呢？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以把 arr[0]( ) 想象为arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr[0]() 
假想为  arr.0()
然后转换为 arr.0.call(arr)
那么里面的 this 就是 arr 了 :)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;this 就是你 call 一个函数时，传入的第一个参数。（请务必背下来「this 就是 call 的第一个参数」）
如果你的函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式。&lt;/p&gt;

&lt;p&gt;以后你遇到所有跟 this 有关的笔试题，都不会有疑问了。&lt;/p&gt;

&lt;p&gt;完。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>