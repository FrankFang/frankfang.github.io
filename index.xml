<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>方应杭的个人网站</title>
    <link>http://fangyinghang.com/</link>
    <description>Recent content in 方应杭的个人网站 </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 09 Nov 2018 02:23:41 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Eventloop Timers and Nexttick</title>
      <link>http://fangyinghang.com/eventloop-timers-and-nexttick/</link>
      <pubDate>Fri, 09 Nov 2018 02:23:41 +0800</pubDate>
      
      <guid>http://fangyinghang.com/eventloop-timers-and-nexttick/</guid>
      <description>

&lt;p&gt;原文：&lt;a href=&#34;http://link.zhihu.com/?target=https%3A//nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;The Node.js Event Loop, Timers, and process.nextTick() | Node.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以下是译文：&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;什么是事件循环-event-loop-注意空格&#34;&gt;什么是事件循环（Event Loop，注意空格）&lt;/h2&gt;

&lt;p&gt;JavaScript 是单线程的，有了 event loop 的加持，Node.js 才可以非阻塞地执行 I/O 操作，把这些操作尽量转移给操作系统来执行。&lt;/p&gt;

&lt;p&gt;我们知道大部分现代操作系统都是多线程的，这些操作系统可以在后台执行多个操作。当某个操作结束了，操作系统就会通知 Node.js，然后 Node.js 就（可能）会把对应的回调函数添加到 poll（轮询）队列，最终这些回调函数会被执行。下文中我们会阐述其细节。&lt;/p&gt;

&lt;h2 id=&#34;event-loop-详解&#34;&gt;Event Loop 详解&lt;/h2&gt;

&lt;p&gt;当 Node.js 启动时，会做这几件事&lt;/p&gt;

&lt;p&gt;1. 初始化 event loop&lt;/p&gt;

&lt;p&gt;2. 开始执行脚本（或者进入 REPL，本文不涉及 REPL）。这些脚本有可能会调用一些异步 API、设定计时器或者调用 process.nextTick()&lt;/p&gt;

&lt;p&gt;3. 开始处理 event loop&lt;/p&gt;

&lt;p&gt;如何处理 event loop 呢？下图给出了一个简单的概览：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ┌───────────────────────┐
┌─&amp;gt;│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │&amp;lt;─────┤  connections, │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中每个方框都是 event loop 中的一个阶段。&lt;/p&gt;

&lt;p&gt;每个阶段都有一个「先入先出队列」，这个队列存有要执行的回调函数（译注：存的是函数地址）。不过每个阶段都有其特有的使命。一般来说，当 event loop 达到某个阶段时，会在这个阶段进行一些特殊的操作，然后执行这个阶段的队列里的所有回调。&lt;/p&gt;

&lt;p&gt;什么时候停止执行这些回调呢？下列两种情况之一会停止：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;队列的操作全被执行完了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行的回调数目到达指定的最大值&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后，event loop 进入下一个阶段，然后再下一个阶段。&lt;/p&gt;

&lt;p&gt;一方面，上面这些操作都有可能添加计时器；另一方面，操作系统会向 poll 队列中添加新的事件，当 poll 队列中的事件被处理时可能会有新的 poll 事件进入 poll 队列。结果，耗时较长的回调函数可以让 event loop 在 poll 阶段停留很久，久到错过了计时器的触发时机。你可以在下文的 timers 章节和 poll 章节详细了解这其中的细节。&lt;/p&gt;

&lt;p&gt;注意，Windows 的实现和 Unix/Linux 的实现稍有不同，不过对本文内容影响不大。本文囊括了 event loop 最重要的部分，不同平台可能有七个或八个阶段，但是上面的几个阶段是我们真正关心的阶段，而且是 Node.js 真正用到的阶段。&lt;/p&gt;

&lt;h2 id=&#34;各阶段概览&#34;&gt;各阶段概览&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;- timers 阶段：这个阶段执行 setTimeout 和 setInterval 的回调函数。&lt;/li&gt;
&lt;li&gt;- I/O callbacks 阶段：不在 timers 阶段、close callbacks 阶段和 check 阶段这三个阶段执行的回调，都由此阶段负责，这几乎包含了所有回调函数。&lt;/li&gt;
&lt;li&gt;- idle, prepare 阶段（译注：看起来是两个阶段，不过这不重要）：event loop 内部使用的阶段（译注：我们不用关心这个阶段）&lt;/li&gt;
&lt;li&gt;- poll 阶段：获取新的 I/O 事件。在某些场景下 Node.js 会阻塞在这个阶段。&lt;/li&gt;
&lt;li&gt;- check 阶段：执行 setImmediate() 的回调函数。&lt;/li&gt;
&lt;li&gt;- close callbacks 阶段：执行关闭事件的回调函数，如 socket.on(&amp;lsquo;close&amp;rsquo;, fn) 里的 fn。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个 Node.js 程序结束时，Node.js 会检查 event loop 是否在等待异步 I/O 操作结束，是否在等待计时器触发，如果没有，就会关掉 event loop。&lt;/p&gt;

&lt;h2 id=&#34;各阶段详解&#34;&gt;各阶段详解&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;timers 阶段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;计时器实际上是在指定多久以后可以执行某个回调函数，而不是指定某个函数的确切执行时间。当指定的时间达到后，计时器的回调函数会尽早被执行。如果操作系统很忙，或者 Node.js 正在执行一个耗时的函数，那么计时器的回调函数就会被推迟执行。&lt;/p&gt;

&lt;p&gt;注意，从原理上来说，poll 阶段能控制计时器的回调函数什么时候被执行。&lt;/p&gt;

&lt;p&gt;举例来说，你设置了一个计时器在 100 毫秒后执行，然后你的脚本用了 95 毫秒来异步读取了一个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);

function someAsyncOperation(callback) {
  // 假设读取这个文件一共花费 95 毫秒
  fs.readFile(&#39;/path/to/file&#39;, callback);
}

const timeoutScheduled = Date.now();

setTimeout(() =&amp;gt; {
  const delay = Date.now() - timeoutScheduled;

  console.log(`${delay}毫秒后执行了 setTimeout 的回调`);
}, 100);

// 执行一个耗时 95 毫秒的异步操作
someAsyncOperation(() =&amp;gt; {
  const startCallback = Date.now();

  // 执行一个耗时 10 毫秒的同步操作
  while (Date.now() - startCallback &amp;lt; 10) {
    // 什么也不做
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 event loop 进入 poll 阶段，发现 poll 队列为空（因为文件还没读完），event loop 检查了一下最近的计时器，大概还有 100 毫秒时间，于是 event loop 决定这段时间就停在 poll 阶段。在 poll 阶段停了 95 毫秒之后，fs.readFile 操作完成，一个耗时 10 毫秒的回调函数被系统放入 poll 队列，于是 event loop 执行了这个回调函数。执行完毕后，poll 队列为空，于是 event loop 去看了一眼最近的计时器（译注：event loop 发现卧槽，已经超时 95 + 10 - 100 = 5 毫秒了），于是经由 check 阶段、close callbacks 阶段绕回到 timers 阶段，执行 timers 队列里的那个回调函数。这个例子中，100 毫秒的计时器实际上是在 105 毫秒后才执行的。&lt;/p&gt;

&lt;p&gt;注意：为了防止 poll 阶段占用了 event loop 的所有时间，libuv（Node.js 用来实现 event loop 和所有异步行为的 C 语言写成的库）对 poll 阶段的最长停留时间做出了限制，具体时间因操作系统而异。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I/O callbacks 阶段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个阶段会执行一些系统操作的回调函数，比如 TCP 报错，如果一个 TCP socket 开始连接时出现了 ECONNREFUSED 错误，一些 *nix 系统就会（向 Node.js）通知这个错误。这个通知就会被放入 I/O callbacks 队列。&lt;/p&gt;

&lt;p&gt;poll 阶段（轮询阶段）&lt;/p&gt;

&lt;p&gt;poll 阶段有两个功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果发现计时器的时间到了，就绕回到 timers 阶段执行计时器的回调。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后再，执行 poll 队列里的回调。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当 event loop 进入 poll 阶段，如果发现没有计时器，就会：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果 poll 队列不是空的，event loop 就会依次执行队列里的回调函数，直到队列被清空或者到达 poll 阶段的时间上限。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果 poll 队列是空的，就会：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果有 setImmediate() 任务，event loop 就结束 poll 阶段去往 check 阶段。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果没有 setImmediate() 任务，event loop 就会等待新的回调函数进入 poll 队列，并立即执行它。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一旦 poll 队列为空，event loop 就会检查计时器有没有到期，如果有计时器到期了，event loop 就会回到 timers 阶段执行计时器的回调。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;check 阶段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个阶段允许开发者在 poll 阶段结束后立即执行一些函数。如果 poll 阶段空闲了，同时存在 setImmediate() 任务，event loop 就会进入 check 阶段。&lt;/p&gt;

&lt;p&gt;setImmediate() 实际上是一种特殊的计时器，有自己特有的阶段。它是通过 libuv 里一个能将回调安排在 poll 阶段之后执行的 API 实现的。&lt;/p&gt;

&lt;p&gt;一般来说，当代码执行后，event loop 最终会达到 poll 阶段，等待新的连接、新的请求等。但是如果一个回调是由 setImmediate() 发出的，同时 poll 阶段空闲下来了，event loop就会结束 poll 阶段进入 check 阶段，不再等待新的 poll 事件。&lt;/p&gt;

&lt;p&gt;（译注：感觉同样的话说了三遍）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;close callbacks 阶段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果一个 socket 或者 handle 被突然关闭（比如 socket.destroy()），那么就会有一个 close 事件进入这个阶段。否则（译注：我没看到这个否则在否定什么，是在否定「突然」吗？），这个 close 事件就会进入 process.nextTick()。&lt;/p&gt;

&lt;h2 id=&#34;setimmediate-vs-settimeout&#34;&gt;setImmediate() vs setTimeout()&lt;/h2&gt;

&lt;p&gt;setImmediate 和 setTimeout 很相似，但是其回调函数的调用时机却不一样。&lt;/p&gt;

&lt;p&gt;setImmediate() 的作用是在当前 poll 阶段结束后调用一个函数。&lt;/p&gt;

&lt;p&gt;setTimeout() 的作用是在一段时间后调用一个函数。&lt;/p&gt;

&lt;p&gt;这两者的回调的执行顺序取决于 setTimeout 和 setImmediate 被调用时的环境。&lt;/p&gt;

&lt;p&gt;如果 setTimeout 和 setImmediate 都是在主模块（main module）中被调用的，那么回调的执行顺序取决于当前进程的性能，这个性能受其他应用程序进程的影响。&lt;/p&gt;

&lt;p&gt;举例来说，如果在主模块中运行下面的脚本，那么两个回调的执行顺序是无法判断的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// timeout_vs_immediate.js
setTimeout(() =&amp;gt; {
  console.log(&#39;timeout&#39;);
}, 0);

setImmediate(() =&amp;gt; {
  console.log(&#39;immediate&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node timeout_vs_immediate.js
timeout
immediate

$ node timeout_vs_immediate.js
immediate
timeout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，如果把上面代码放到 I/O 操作的回调里，setImmediate 的回调就总是优先于 setTimeout 的回调：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// timeout_vs_immediate.js
const fs = require(&#39;fs&#39;);

fs.readFile(__filename, () =&amp;gt; {
  setTimeout(() =&amp;gt; {
    console.log(&#39;timeout&#39;);
  }, 0);
  setImmediate(() =&amp;gt; {
    console.log(&#39;immediate&#39;);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node timeout_vs_immediate.js
immediate
timeout

$ node timeout_vs_immediate.js
immediate
timeout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;setImmediate 的主要优势就是，如果在 I/O 操作的回调里，setImmediate 的回调总是比 setTimeout 的回调先执行。（译者注：怎么总是把一个道理翻来覆去地说）&lt;/p&gt;

&lt;h2 id=&#34;process-nexttick&#34;&gt;process.nextTick()&lt;/h2&gt;

&lt;p&gt;你可能发现 process.nextTick() 这个重要的异步 API 没有出现在任何一个阶段里，那是因为从技术上来讲 process.nextTick() 并不是 event loop 的一部分。实际上，不管 event loop 当前处于哪个阶段，nextTick 队列都是在当前阶段后就被执行了。&lt;/p&gt;

&lt;p&gt;回过头来看我们的阶段图，你在任何一个阶段调用 process.nextTick(回调)，回调都会在当前阶段继续运行前被调用。这种行为有的时候会造成不好的结果，因为你可以递归地调用 process.nextTick()，这样 event loop 就会一直停在当前阶段不走……无法进入 poll 阶段。&lt;/p&gt;

&lt;p&gt;为什么 Node.js 要这样设计 process.nextTick 呢？&lt;/p&gt;

&lt;p&gt;因为有些异步 API 需要保证一致性，即使可以同步完成，也要保证异步操作的顺序，看下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function apiCall(arg, callback) {
  if (typeof arg !== &#39;string&#39;)
    return process.nextTick(callback, new TypeError(&#39;argument should be string&#39;));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码检查了参数的类型，如果类型不是 string，就会将 error 传递给 callback。&lt;/p&gt;

&lt;p&gt;这段代码保证 apiCall 调用之后的同步代码能在 callback 之前运行。用于用到了 process.nextTick()，所以 callback 会在 event loop 进入下一个阶段前执行。为了做到这一点，JS 的调用栈可以先 unwind 再执行 nextTick 的回调，这样无论你递归调用多少次 process.nextTick() 都不会造成调用栈溢出（V8 里对应 RangeError: Maximum call stack size exceeded）。&lt;/p&gt;

&lt;p&gt;如果不这样设计，会造成一些潜在的问题，比如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let bar;

// 这是一个异步 API，但是却同步地调用了 callback
function someAsyncApiCall(callback) { callback(); }

//`someAsyncApiCall` 在执行过程中就调用了回调
someAsyncApiCall(() =&amp;gt; {
  // 此时 bar 还没有被赋值为 1
  console.log(&#39;bar&#39;, bar); // undefined
});

bar = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开发者虽然把 someAsyncApiCall 命名得像一个异步函数，但是实际上这个函数是同步执行的。当 someAsyncApiCall 被调用时，回调也在同一个 event loop 阶段被调用了。结果回调中就无法得到 bar 的值。因为赋值语句还没被执行。&lt;/p&gt;

&lt;p&gt;如果把回调放在 process.nextTick() 中执行，后面的赋值语句就可以先执行了。而且 process.nextTick() 的回调会在 eventLoop 进入下一个阶段前调用。（译注：又是把一个道理翻来覆去地讲）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let bar;

function someAsyncApiCall(callback) {
  process.nextTick(callback);
}

someAsyncApiCall(() =&amp;gt; {
  console.log(&#39;bar&#39;, bar); // 1
});

bar = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个更符合现实的例子是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const server = net.createServer(() =&amp;gt; {}).listen(8080);

server.on(&#39;listening&#39;, () =&amp;gt; {});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.listen(8080) 这句话是同步执行的。问题在于 listening 时间无法被触发，因为 listening 的监听代码在 .listen(8080) 的后面。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，.listen() 函数可以使用 process.nextTick() 来执行 listening 事件的回调。&lt;/p&gt;

&lt;h2 id=&#34;process-nexttick-vs-setimmediate&#34;&gt;process.nextTick() vs setImmediate()&lt;/h2&gt;

&lt;p&gt;这两个函数功能很像，而且名字也很令人疑惑。&lt;/p&gt;

&lt;p&gt;process.nextTick() 的回调会在当前 event loop 阶段「立即」执行。&lt;/p&gt;

&lt;p&gt;setImmediate() 的回调会在后续的 event loop 周期（tick）执行。&lt;/p&gt;

&lt;p&gt;（译注：看起来名字叫反了）&lt;/p&gt;

&lt;p&gt;二者的名字应该互换才对。process.nextTick() 比 setImmediate() 更 immediate（立即）一些。&lt;/p&gt;

&lt;p&gt;这是一个历史遗留问题，而且为了保证向后兼容性，也不太可能得到改善。所以就算这两个名字听起来让人很疑惑，也不会在未来有任何变化。&lt;/p&gt;

&lt;p&gt;我们推荐开发者在任何情况下都使用 setImmediate()，因为它的兼容性更好，而且它更容易理解。&lt;/p&gt;

&lt;h2 id=&#34;什么时候用-process-nexttick&#34;&gt;什么时候用 process.nextTick()？&lt;/h2&gt;

&lt;p&gt;There are two main reasons:&lt;/p&gt;

&lt;p&gt;使用的理由有两个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;让开发者处理错误、清除无用的资源，或者在 event loop 当前阶段结束前尝试重新请求资源&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;有时候有必要让一个回调在调用栈 unwind 之后，event loop 进入下阶段之前执行&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了让代码更合理，我们可能会写这样的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const server = net.createServer();
server.on(&#39;connection&#39;, (conn) =&amp;gt; { });

server.listen(8080);
server.on(&#39;listening&#39;, () =&amp;gt; { });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设 listen() 在 event loop 一启动的时候就执行了，而 listening 事件的回调被放在了 setImmediate() 里，listen 动作是立即发生的，如果想要 event loop 执行 listening 回调，就必须先经过 poll 阶段，当时 poll 阶段有可能会停留，以等待连接，这样一来就有可能出现 connect 事件的回调比 listening 事件的回调先执行。（译注：这显然不合理，所以我们需要用 process.nextTick）&lt;/p&gt;

&lt;p&gt;再举一个例子，一个类继承了 EventEmitter，而且想在实例化的时候触发一个事件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const EventEmitter = require(&#39;events&#39;);
const util = require(&#39;util&#39;);

function MyEmitter() {
  EventEmitter.call(this);
  this.emit(&#39;event&#39;);
}
util.inherits(MyEmitter, EventEmitter);

const myEmitter = new MyEmitter();
myEmitter.on(&#39;event&#39;, () =&amp;gt; {
  console.log(&#39;an event occurred!&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你不能直接在构造函数里执行 this.emit(&amp;lsquo;event&amp;rsquo;)，因为这样的话后面的回调就永远无法执行。把 this.emit(&amp;lsquo;event&amp;rsquo;) 放在 process.nextTick() 里，后面的回调就可以执行，这才是我们预期的行为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const EventEmitter = require(&#39;events&#39;);
const util = require(&#39;util&#39;);

function MyEmitter() {
  EventEmitter.call(this);

  // use nextTick to emit the event once a handler is assigned
  process.nextTick(() =&amp;gt; {
    this.emit(&#39;event&#39;);
  });
}
util.inherits(MyEmitter, EventEmitter);

const myEmitter = new MyEmitter();
myEmitter.on(&#39;event&#39;, () =&amp;gt; {
  console.log(&#39;an event occurred!&#39;);
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>我的课程</title>
      <link>http://fangyinghang.com/my/courses/</link>
      <pubDate>Thu, 08 Nov 2018 04:04:02 +0800</pubDate>
      
      <guid>http://fangyinghang.com/my/courses/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/63308031-98f4-4907-ade4-c22d4aa82f27&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;React 入门（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/6f105ef5-8969-4863-82e7-beb162ddc5b3&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;TypeScript 入门（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/9ff75915-a19f-451d-b3a5-85feed5a6bc1&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;SCSS 入门（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/6d63da67-6eea-4711-aeb4-0c3a949341dc&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;自制 Vue UI 框架（连载中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/24f54465-854f-4de7-9808-72a0bf5b3181&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS 深入浅出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/12a78a03-35f9-42ea-9b37-540540460f6e&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ES6 深入浅出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/003b1951-22af-4821-ad80-d2880c0074eb&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;CSS 深入浅出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiedaimala.com/courses/ec3a5e28-02da-47d6-9226-927db23e82a2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;前端零基础入门&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我的经历</title>
      <link>http://fangyinghang.com/my/resume/</link>
      <pubDate>Wed, 07 Nov 2018 04:04:02 +0800</pubDate>
      
      <guid>http://fangyinghang.com/my/resume/</guid>
      <description>&lt;p&gt;毕业于华中科技大学软件工程专业，先后在腾讯、阿里巴巴、彩程担任前端工程师。
现在在 &lt;a href=&#34;https://jirengu.com&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;饥人谷&lt;/a&gt; 讲课、开发、写作。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;技术栈&#34;&gt;技术栈&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Web 前端开发技术（CSS、JavaScript、TypeScript、Vue、React、Angular 等）&lt;/li&gt;
&lt;li&gt;Web 后端开发技术（Ruby on Rails、Node.js 等）&lt;/li&gt;
&lt;li&gt;正在学习 Kotlin、Swift&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;工具箱&#34;&gt;工具箱&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;编辑器喜欢用 vim、WebStorm、RubyMine，&lt;a href=&#34;https://jscode.me/t/topic/851&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;vim 配置&lt;/a&gt; 还挺简洁的。&lt;/li&gt;
&lt;li&gt;在 iTerm2.app + zshell 里运行命令行&lt;/li&gt;
&lt;li&gt;使用 Paste.app 管理剪切板&lt;/li&gt;
&lt;li&gt;使用 xScope + Sip + Sketch 切图&lt;/li&gt;
&lt;li&gt;使用印象笔记管理知识&lt;/li&gt;
&lt;li&gt;使用 The Hit List.app + Tower.im 管理工作任务&lt;/li&gt;
&lt;li&gt;讲课时非常喜欢用 &lt;a href=&#34;https://detail.tmall.com/item.htm?id=17866298588&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Wacom 数位板&lt;/a&gt; 演示思路&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>jQuery 都过时了，那我还学它干嘛？</title>
      <link>http://fangyinghang.com/why-still-jquery/</link>
      <pubDate>Mon, 15 Oct 2018 16:22:04 +0800</pubDate>
      
      <guid>http://fangyinghang.com/why-still-jquery/</guid>
      <description>

&lt;p&gt;今天饥人谷的新生问我&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;请问现在我还需要学习 jQuery 吗？听你在知乎说 jQuery 已经过时了，是不是就不用学了？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;短答案&#34;&gt;短答案&lt;/h2&gt;

&lt;p&gt;jQuery 还是可以学一学的，学了之后对写代码和封装库很有帮助。&lt;/p&gt;

&lt;p&gt;现在的「新人」依然可以学习 jQuery 的思想，因为以「新人」的水平，直接理解 Vue / React 的思想难度较大，jQuery 是一个很不错的中间过渡，因为 jQuery 也蕴含了非常多的编程套路。&lt;/p&gt;

&lt;p&gt;但是如果你不想学，就不学吧。直接去学 Vue / React 会难一点，但也能学会。&lt;/p&gt;

&lt;h2 id=&#34;长答案&#34;&gt;长答案：&lt;/h2&gt;

&lt;p&gt;jQuery 当然过时了。&lt;/p&gt;

&lt;p&gt;距离我上次在项目中使用 jQuery，可能已经快两年时间了（除去上课时演示功能时用 jQuery）。回想我学习 jQuery 的过程，还挺神奇的。&lt;/p&gt;

&lt;p&gt;当年我在大学的技术小组里做 C# 网站开发，需要用到 jQuery 特效，组里的一名小伙伴会用一点 jQuery，很快就用 .animate 做出了让我啧啧称奇的特效。我觉得 jQuery 好神奇啊，虽然我当时连 JS 都不会。&lt;/p&gt;

&lt;p&gt;于是我立马买了一本《锋利的 jQuery》，硬看。&lt;/p&gt;

&lt;p&gt;什么叫「硬看」呢？因为我不会 JS，而且我并没有照着书上敲代码，仅仅使用眼睛「看 jQuery 代码」。神奇的是——我居然很快看懂了几乎整本书。以至于那位会用 jQuery 的小伙伴遇到 bug 问我时我能直接给出解答，看起来他并没有看《锋利的 jQuery》这本书（笑）。&lt;/p&gt;

&lt;p&gt;到了 2018 年，几乎已经没有新项目会使用 jQuery 来开发了；即使有，也是一件不值得拿出来炫耀的事情。那为什么我还是建议学习 jQuery 呢？&lt;/p&gt;

&lt;p&gt;原因如下。&lt;/p&gt;

&lt;h2 id=&#34;jquery-教你如何设计-api&#34;&gt;jQuery 教你如何设计 API&lt;/h2&gt;

&lt;p&gt;上文说到我一个不会 JS 的人居然能看懂 jQuery 的书，其实这不是因为我厉害，而是因为 jQuery 的 API 设计得太人性化了！&lt;/p&gt;

&lt;p&gt;举几个例子给大家看看：&lt;/p&gt;

&lt;p&gt;第一个是 jQuery 对事件监听的简化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 那时，如果不用 jQuery，监听事件（兼容 IE 6）你要这么写
if (button.addEventListener)  
  button.addEventListener(&#39;click&#39;,fn);
else if (button.attachEvent) { 
  button.attachEvent(&#39;onclick&#39;, fn);
}else {
  button.onclick = fn;
}

// 但是如果你用 jQuery，你只需要这么写
$(button).on(&#39;click&#39;, fn)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个是 jQuery 对元素选择的简化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 如果你想获取 .nav &amp;gt; .navItem 对应的所有元素，用 jQuery 是这样写的
$(&#39;.nav &amp;gt; .navItem&#39;)

// 在 IE 6 上，你得这么写
var navItems = document.getElementsByClassName(&#39;navItem&#39;)
var result = []
for(var i = 0; i &amp;lt; navItems.length; i++){
  if(navItems[i].parentNode.className.match(/\bnav\b/){
    result.push(navItems[i])
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有没有发现 jQuery 的代码一读就读懂了？可读性非常强！&lt;/p&gt;

&lt;p&gt;当时我作为一个新人，每每看到 jQuery 那优雅的 API，都禁不住去思考 jQuery 到底是怎么实现的，我自己能不能实现出来（但我并不推荐看 jQuery 源码）。本着这样的想法，我学会了很多编程技巧。&lt;/p&gt;

&lt;p&gt;为什么有些人代码水平老是提不高了，就是因为不会造轮子，不会设计优雅的 API，更不会实现优雅的 API，只会调用其他库或框架提供的功能（中枪的举手）。&lt;/p&gt;

&lt;p&gt;而 jQuery 则提供了一个简单而又经典的范例供大家学习。&lt;/p&gt;

&lt;p&gt;不信的话我们就来看看 jQuery 用到了哪些所谓的设计模式（其实就是编程套路）吧。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;发布订阅模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var eventHub = $({})
eventHub.on(&#39;xxx&#39;, function(){ console.log(&#39;收到&#39;) })
eventHub.trigger(&#39;xxx&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用原型继承实现插件系统&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.fn.modal = function(){ ... }
$(&#39;#div1&#39;).modal()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vue 2 的插件也是类似的思路哦&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事件委托&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;).on(&#39;click&#39;, &#39;span&#39;, function(){...})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说实话，你在 2018 年找前端让他写一个事件委托，我保证 90% 写出来的代码都是有「明显」bug 的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;链式调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;).text(&#39;hi&#39;).addClass(&#39;red&#39;).animate({left: 100})
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数重载（伪）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(fn)
$(&#39;div&#39;)
$(div)
$($(div))
$(&#39;span&#39;, &#39;#scope1&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会发现 $ 这个函数的参数可以是函数、字符串、元素和 jQuery 对象，甚至还能接受多个参数，这种重载是怎么做到的？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;命名空间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 你的插件在一个 button 上绑定了很多事件
$button.on(&#39;click.plugin&#39;, function(){...})
$button.on(&#39;mouseenter.plugin&#39;, function(){...})
// 然后你想在某个时刻移除以上所有事件
$button.off(&#39;.plugin&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不用 jQuery 就很麻烦了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;高阶函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fn2 = $.proxy(fn1, asThis, param1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$.proxy 接受一个函数，返回一个新的函数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其他就不一一列举了。&lt;/p&gt;

&lt;h2 id=&#34;jquery-的-api-风格依然在流行&#34;&gt;jQuery 的 API 风格依然在流行&lt;/h2&gt;

&lt;p&gt;我们把 jQuery 和 Axios 做一下对比：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajax({url:&#39;/api&#39;, method:&#39;get&#39;})
$.get(&#39;/api&#39;).then(fn1,fn2)

axios({ url: &#39;/api&#39;, method: &#39;get&#39;})
axios.get(&#39;/api&#39;).then(fn1, fn2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么 2018 年流行的 axios 跟 jQuery.ajax 这么相像呢？&lt;/p&gt;

&lt;p&gt;因为 jQuery 的 API 实在太好用了！搞得新库根本没法超越它，没有办法设计出更简洁的 API 了。毕竟 jQuery 也是在前端界流行近十年。&lt;/p&gt;

&lt;p&gt;所以你学了 jQuery 很容易过渡其他类似的新库。&lt;/p&gt;

&lt;h2 id=&#34;jquery-也能做-mvc&#34;&gt;jQuery 也能做 MVC&lt;/h2&gt;

&lt;p&gt;很多人以为前端框架是从 Vue、React 和 Angular 才开始的，其实 jQuery 时代早就有基于 jQuery 的 MV* 库了，比如著名的 Backbone.js 和 Marionette.js。&lt;/p&gt;

&lt;p&gt;看看下面的 Backbone 应用代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var TodoView = Backbone.View.extend({
    tagName:  &#39;div&#39;,
    template: _.template($(&#39;#item-template&#39;).html()),
    events: {
        &#39;click .toggle&#39;: &#39;xxx&#39;,
    },
    initialize: function () {
        this.listenTo(this.model, &#39;change&#39;, this.render);
    },
    render: function () {
        if (this.model.changed.id !== undefined) {return; }
        this.$el.html(this.template(this.model.toJSON()));
        return this;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AngularJS、Vue 1.x、Vue 2.x 其实都是顺着 Backbone MVC 的思路慢慢优化、改造得来的，如果你提前了解 Backbone 作为知识铺垫，那么理解 Vue 是非常容易的。如果面试官问你 MVC 和 MVVM 的区别，你也是很容易就可以答出来的。&lt;/p&gt;

&lt;p&gt;最后就引用我之前的一个回答作为结尾来说明学习 jQuery 意义：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/20521802/answer/290354219&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;完全理解jQuery源代码，在前端行业算什么水平？&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;说明你&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;精通正则表达式&lt;/li&gt;
&lt;li&gt;了解闭包&lt;/li&gt;
&lt;li&gt;了解原型链&lt;/li&gt;
&lt;li&gt;精通 DOM API&lt;/li&gt;
&lt;li&gt;了解各种设计模式（事件、Promise、伪重载、装饰器模式等）&lt;/li&gt;
&lt;li&gt;精通 DOM 事件&lt;/li&gt;
&lt;li&gt;了解旧浏览器的各种特性（bug）&lt;/li&gt;
&lt;li&gt;了解模块化&lt;/li&gt;
&lt;li&gt;了解浏览器渲染原理&lt;/li&gt;
&lt;li&gt;精通 AJAX&lt;/li&gt;
&lt;li&gt;了解 HTTP 请求&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以秒杀中国 80% 的前端&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>为什么不推荐去外包公司</title>
      <link>http://fangyinghang.com/dont-join-outsourcing-company/</link>
      <pubDate>Tue, 28 Aug 2018 02:20:36 +0800</pubDate>
      
      <guid>http://fangyinghang.com/dont-join-outsourcing-company/</guid>
      <description>

&lt;p&gt;为什么大部分程序员都不去「外包」公司？&lt;/p&gt;

&lt;p&gt;短答案：99% 的外包公司都是血汗工厂，压榨劳力，真真儿地是「用程序员的生命换钱」。&lt;/p&gt;

&lt;p&gt;目前我只知道一家外包公司不是这样，那就是 &lt;a href=&#34;https://www.zhihu.com/question/24738030&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ThoughtWorks&lt;/a&gt;（当然也有人认为 ThoughtWorks 也挺累的）。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;大部分外包公司，都是在外面跟甲方签好了合同，保证多久能开发出项目，然后收尾款。&lt;/p&gt;

&lt;p&gt;这就导致了两个问题：&lt;/p&gt;

&lt;p&gt;一，deadline 前必须完成，不管程序员是通宵还是周六周日上班，必须完成，否则公司可能拿不到钱。&lt;/p&gt;

&lt;p&gt;二，这个项目做完，马上就有下一个需要你加班的项目，你没有喘息的机会。&lt;/p&gt;

&lt;p&gt;另外我们都知道，这个世界上有很多外包公司，所以他们之间会互相竞争，甲公司说30天完成，乙公司为了抢单就敢报20天完成，最终的天数基本就是程序员没日没夜加班才能完成的天数（也就是程序员生理极限天数）。&lt;/p&gt;

&lt;p&gt;久而久之就出现劣币驱逐良币的现象：外包公司不压榨程序员就没法跟其他外包公司竞争……&lt;/p&gt;

&lt;p&gt;还有一个最大的问题，外包公司接到的项目一般都是量大的、没有深度的项目，很有可能你一年接触到五个企业微信公众号的项目，这将会导致你技能单一，没有市场竞争力。&lt;/p&gt;

&lt;h2 id=&#34;如果你已经得到了外包公司的-offer&#34;&gt;如果你已经得到了外包公司的 offer&lt;/h2&gt;

&lt;p&gt;如果是这样，那么你应该&lt;/p&gt;

&lt;p&gt;一、尽量再争取一下其他公司的 offer，有了多个 offer 你才有得选。&lt;/p&gt;

&lt;p&gt;二、如果你得到的 offer 全是外包公司的，那么很不幸，你就要&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;做好用生命换工资的准备&lt;/li&gt;
&lt;li&gt;做好一年内的学习和跳槽的计划&lt;/li&gt;
&lt;li&gt;把工资要高一点，至少比你的心理价位高 20% 以上，因为周六加班是默认的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三、如果你在外包公司待了超过两年，那么你很可能只能跳到另一家外包公司，所以切记，早点脱坑。&lt;/p&gt;

&lt;h2 id=&#34;公司实行-996-了-我要怎么提升自己&#34;&gt;公司实行 996 了，我要怎么提升自己？&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;利用工作时间学习并提升自己&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;没错，如果公司 996，聪明的程序员自然就会想办法用工作时间来做自己的事情，让公司得不偿失。&lt;/p&gt;

&lt;h2 id=&#34;外派是什么&#34;&gt;外派是什么？&lt;/h2&gt;

&lt;p&gt;外派是指外包公司不把你关在一个屋子里开发，而是让你去对方的公司开发。但是你的工资不是对方公司给。&lt;/p&gt;

&lt;p&gt;外派到阿里的工作还是不错的。一般不会周六上班。所以比外包稍微好一丢丢。&lt;/p&gt;

&lt;p&gt;不过外派的问题就是总感觉自己是二等人，因为你享受不到阿里的任何福利，而你旁边办公室的人却可以。&lt;/p&gt;

&lt;p&gt;对于外派，我的建议也是：早点跳槽。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;愿你能坑到坑你的公司。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我写了一个基于 Vue 的 UI 框架——轱辘 UI</title>
      <link>http://fangyinghang.com/gulu-ui/</link>
      <pubDate>Fri, 03 Aug 2018 16:32:18 +0800</pubDate>
      
      <guid>http://fangyinghang.com/gulu-ui/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://frankfang.github.io/gulu/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官方文档&lt;/a&gt; | &lt;a href=&#34;https://github.com/FrankFang/gulu&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;源码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;轱辘 UI 是一个不太一样的 UI 框架。&lt;/p&gt;

&lt;p&gt;本 UI 框架是一个「面向源码阅读者」的框架。如果对你有帮助，请不要吝惜你的 star。&lt;/p&gt;

&lt;p&gt;也就是说，我制作这个框架的目的就是让前端新人学习轮子的制作思路。所有代码都追求可读性。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你可以通过查看逐个 commit 来学习本框架的制作思路&lt;/li&gt;
&lt;li&gt;也可以通过我&lt;a href=&#34;https://xiedaimala.com/courses/6d63da67-6eea-4711-aeb4-0c3a949341dc&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;录制的视频&lt;/a&gt;来学习
（抱歉，由于制作非常耗时，所以视频是收费的。不过项目搭建过程的录屏是&lt;strong&gt;免费&lt;/strong&gt;的，这几节视频能帮你快速从零开始本项目。）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你想从第一个commit 开始看，请点击&lt;a href=&#34;https://github.com/FrankFang/gulu/commits/master?after=36fbd6867d0a223184ad67e3d2bc3569e88847e0+104&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果你对代码有疑问，欢迎&lt;a href=&#34;https://github.com/frankfang/gulu/issues&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;提issue&lt;/a&gt;，我会回答你的疑问。也可以在本文末尾加群咨询。&lt;/p&gt;

&lt;p&gt;本 UI 框架是基于 Vue 2 实现的。&lt;/p&gt;

&lt;p&gt;注意：本 UI 框架的代码尚未完全完工（目前代码大概完成 50%），请不要在生产环境中使用本 UI 框架。&lt;/p&gt;

&lt;h2 id=&#34;你能学到什么&#34;&gt;你能学到什么&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;单元测试、覆盖率、持续集成等工程概念&lt;/li&gt;
&lt;li&gt;重构、TDD/BDD、设计模式、单向数据流等技术概念&lt;/li&gt;
&lt;li&gt;Vue 的几乎所有功能，并且是深入理解这些功能，而不是肤浅理解&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;有哪些轮子&#34;&gt;有哪些轮子&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;简单轮子：按钮、输入框、网格、布局、Toast、Tabs、Popover、手风琴（代码已完成）&lt;/li&gt;
&lt;li&gt;进阶轮子：级联选择、无缝轮播、响应式导航条、分页、表单验证、Table、图片上传、Sticky、Tree、Suggestion、Datepicker（代码未完成）&lt;/li&gt;
&lt;li&gt;其他：路由、状态管理（代码未完成）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：这只是目前的计划，具体要完成的轮子可能与上面有出入。&lt;/p&gt;

&lt;h2 id=&#34;项目特点&#34;&gt;项目特点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;使用 Travis CI 进行持续集成&lt;/li&gt;
&lt;li&gt;有丰富的单元测试，项目完成时，期望测试覆盖率超过 90%&lt;/li&gt;
&lt;li&gt;自说明的代码，即使没有注释，你也能看懂&lt;/li&gt;
&lt;li&gt;初期我使用 parcel 构建方便新人上手，后期改为 Vue Cli 3 以实现更多功能&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;我几年前曾经发表过《&lt;a href=&#34;https://juejin.im/post/58ef6004ac502e006c16f2d6&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;笨办法学前端&lt;/a&gt;》一文，
当时我觉得开源社区里虽然有很多不错的库，但是这些库都是以实用为主，其源码并不适合&lt;strong&gt;新人&lt;/strong&gt;阅读。&lt;/p&gt;

&lt;p&gt;于是我业余时间用原生 JS 造了几个轮子放在 GitHub，没想到居然有几百人关注，还希望我能发布更详细的教程。&lt;/p&gt;

&lt;p&gt;但是我当时并没有时间来做更详细的教程。&lt;/p&gt;

&lt;p&gt;现在我终于……还是很忙，不过我决定用每周六和周日来录制「造轮子」的视频。&lt;/p&gt;

&lt;p&gt;这一次为了顺应前端的潮流，我直接采用 Vue 2 来造轮子。如果你正在学习 Vue 2，那么轱辘 UI 的源码会非常适合你阅读。&lt;/p&gt;

&lt;h2 id=&#34;视觉稿&#34;&gt;视觉稿&lt;/h2&gt;

&lt;p&gt;本 UI 框架借鉴了一些成熟 UI 框架（如 Framework7、Element UI 和 Ant Design）的外观，简化之后我自己制作了一个&lt;a href=&#34;https://www.yuque.com/u29422/gulu/artboards/22283&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;视觉稿&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果你发现视觉稿有什么不足的地方，可以直接在上面留言，我也会看到。&lt;/p&gt;

&lt;h2 id=&#34;为什么叫轱辘ui&#34;&gt;为什么叫轱辘UI&lt;/h2&gt;

&lt;p&gt;因为轱辘就是「轮子」的意思，这个项目几乎就是在造轮子。&lt;/p&gt;

&lt;h2 id=&#34;微信交流群&#34;&gt;微信交流群&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qr.jirengu.com/api/taskUrl?tid=8&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;点击查看二维码&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我用了两个月的时间才理解 let</title>
      <link>http://fangyinghang.com/let-in-js/</link>
      <pubDate>Thu, 27 Jul 2017 13:39:30 +0800</pubDate>
      
      <guid>http://fangyinghang.com/let-in-js/</guid>
      <description>

&lt;p&gt;当然不是说用完整的两个月时间来理解 let，而是零零碎碎地理解，同时我还要想着怎么写出一篇文章把这个事情说清楚。&lt;/p&gt;

&lt;p&gt;在 let 刚出来的时候，我就「以为」我理解了 let。然鹅在过去的两个月里，我对 let 的理解发生了一波三折的变化。&lt;/p&gt;

&lt;p&gt;我写这篇文章，是希望我的学习过程，能对你自学有帮助。&lt;/p&gt;

&lt;h2 id=&#34;初识-let&#34;&gt;初识 let&lt;/h2&gt;

&lt;p&gt;跟很多人一样，我第一次了解 let 的特性是从 MDN 的文档：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我得到的信息有这么几条：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;let 声明的变量的作用域是块级的；&lt;/li&gt;
&lt;li&gt;let 不能重复声明已存在的变量；&lt;/li&gt;
&lt;li&gt;let 有暂时死区，不会被提升。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大部分人应该都是这么认为的，我也是这么理解的。&lt;/p&gt;

&lt;p&gt;这个理解「没有问题」，但是不够「全面和深刻」。&lt;/p&gt;

&lt;h2 id=&#34;第一次质疑&#34;&gt;第一次质疑&lt;/h2&gt;

&lt;p&gt;我第一次质疑我的理解是在遇到 for 循环的时候，代码如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代码段1
var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li
for( var i=0; i&amp;lt;liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家都知道依次点击 li 会打印出 5 个 5。如果把 var i 改成 let i，就会分别打印出 0、1、2、3、4：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代码段2
var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li
for( let i=0; i&amp;lt;liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，用我之前的知识来理解这个代码是不能自圆其说的。因为代码中依然只声明了一个 i，在 for 循环结束后，i 的值还是会变成 5 才对。&lt;/p&gt;

&lt;p&gt;这说明我的理解有误。&lt;/p&gt;

&lt;p&gt;于是我去看 MDN 的例子，发现鸡贼的 MDN 巧妙地避开了这个问题，它的例子是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;你看 MDN 的例子，在每次循环的时候用 let j 保留的 i 的值，所以在 i 变化的时候，j 并不会变化。而console.log 的是 j，所以不会出现 5 个 5。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么 MDN 要故意声明一个 j 呢，为什么不直接用 i 呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我猜测 MDN 为了简化知识，隐瞒了什么。&lt;/p&gt;

&lt;p&gt;于是我去看了看 ES 文档，其中的 &lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement-runtime-semantics-labelledevaluation&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;13.7.4.7 章节&lt;/a&gt;
清楚地说明了个中缘由，但是由于说得太清楚了，很多人都看不下去，不信你可以试试。&lt;/p&gt;

&lt;p&gt;我说一下我的理解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;for( let i = 0; i&amp;lt; 5; i++)&lt;/code&gt; 这句话的圆括号之间，有一个隐藏的作用域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for( let i = 0; i&amp;lt; 5; i++) { 循环体 }&lt;/code&gt; 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。&lt;/li&gt;
&lt;li&gt;其他细节就不说了，太细碎了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说上面的代码段2可以近似近似近似地理解为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代码段3
var liList = document.querySelectorAll(&#39;li&#39;) // 共5个li
for( let i=0; i&amp;lt;liList.length; i++){
  let i = 隐藏作用域中的i // 看这里看这里看这里
  liList[i].onclick = function(){
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那样的话，5 次循环，就会有 5 个不同的 i，console.log 出来的 i 当然也是不同的值。&lt;/p&gt;

&lt;p&gt;再加上隐藏作用域里的 i，一共有 6 个 i。&lt;/p&gt;

&lt;p&gt;这就是 MDN 加那句 &lt;code&gt;let j = i&lt;/code&gt; 的原因：方便新人理解。&lt;/p&gt;

&lt;p&gt;总得来说就是 let/const 在与 for 一起用时，会有一个 perIterationBindings 的概念（一种语法糖）。&lt;/p&gt;

&lt;p&gt;从此之后，我就开始怀疑我对 let 的所有理解了。&lt;/p&gt;

&lt;h2 id=&#34;第二次质疑&#34;&gt;第二次质疑&lt;/h2&gt;

&lt;p&gt;我在 StackOverflow 上闲逛的时候，无意中发现了一个是关于「let 到底有没有提升」的问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Are variables declared with let or const not hoisted in ES6?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中一个高票回答认为 JS 中所有的声明（var/let/const/function/class），都存在提升，理由是如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = &amp;quot;global&amp;quot;;
// function scope:
(function() {
    x; // not &amp;quot;global&amp;quot;

    var/let/… x;
}());
// block scope (not for `var`s):
{
    x; // not &amp;quot;global&amp;quot;

    let/const/… x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我觉得他说得挺有道理的。于是我又去 MDN 和 ECMAScript 翻了翻，发现两处疑点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MDN 关于 let 是否存在提升的章节，被编辑了两次，第一次说存在提升，第二次说不存在提升（参考 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let%24compare?locale=en-US&amp;amp;to=1242757&amp;amp;from=1242229&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;2017 年 3 月 10 号的变更记录&lt;/a&gt;）。也就是说 MDN 的维护者都在这个问题上产生过分歧，更何况我们了。&lt;/li&gt;
&lt;li&gt;ES 文档里出现了「var/let hoisting」字样。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;鉴于此，我认为应该尊重 ES 文档，认为 let 确实存在提升。只不过由于暂时死区的限制，你不能在 let x 之前使用 let（详见我的那篇 let 声明会提升（hoist）吗？）。&lt;/p&gt;

&lt;h2 id=&#34;故事并没有结束&#34;&gt;故事并没有结束&lt;/h2&gt;

&lt;p&gt;当一个疑问一直存在你脑中时，你会在潜意识中不停地对它进行消化和思考。&lt;/p&gt;

&lt;p&gt;上面说到我认为 let 存在提升的主要原因是 ES 文档中出现了「var/let hoisting」字样。&lt;/p&gt;

&lt;p&gt;但是我在咨询 TC39 的成员 &lt;a href=&#34;https://twitter.com/rwaldron&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Rick Waldron&lt;/a&gt; 时，他是这么说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You&amp;rsquo;re misunderstanding the intention of that (non-normative) Note. let and const do not hoist as var and function decls do.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而且还细心地专门写了一个 &lt;a href=&#34;https://gist.github.com/rwaldron/ca35924d59ddc60a6aa165e1e4a3acda&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;gist&lt;/a&gt; 来详细解释（twitter 有 140 字限制）。&lt;/p&gt;

&lt;p&gt;既然 TC39 的 representative 都说了 let hoisting 不是一个正式词汇，那我就应该重新思考一下什么是「提升」了。&lt;/p&gt;

&lt;p&gt;于是就有了这篇文章，我想要说一下我对「提升」的理解。你看完之后，就知道 let 到底有没有「提升」。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先明确一点：提升不是一个技术名词。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」&lt;/p&gt;

&lt;p&gt;有的地方把创建说成是声明（declare），为了将这个概念与变量声明区别开，我故意不使用声明这个字眼。&lt;/p&gt;

&lt;p&gt;有的地方把初始化叫做绑定（binding），但我感觉这个词不如初始化形象。&lt;/p&gt;

&lt;h2 id=&#34;创建-初始化和赋值&#34;&gt;创建、初始化和赋值&lt;/h2&gt;

&lt;h3 id=&#34;我们来看看-var-声明的-创建-初始化和赋值-过程&#34;&gt;我们来看看 var 声明的「创建、初始化和赋值」过程&lt;/h3&gt;

&lt;p&gt;假设有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fn(){
  var x = 1
  var y = 2
}
fn()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在执行 fn 时，会有以下过程（不完全）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;进入 fn，为 fn 创建一个环境。&lt;/li&gt;
&lt;li&gt;找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。&lt;/li&gt;
&lt;li&gt;将这些变量「初始化」为 undefined。&lt;/li&gt;
&lt;li&gt;开始执行代码&lt;/li&gt;
&lt;li&gt;x = 1 将 x 变量「赋值」为 1&lt;/li&gt;
&lt;li&gt;y = 2 将 y 变量「赋值」为 2&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。&lt;/p&gt;

&lt;p&gt;这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。&lt;/p&gt;

&lt;h3 id=&#34;接下来来看-function-声明的-创建-初始化和赋值-过程&#34;&gt;接下来来看 function 声明的「创建、初始化和赋值」过程&lt;/h3&gt;

&lt;p&gt;假设代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn2()

function fn2(){
  console.log(2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JS 引擎会有以下过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找到所有用 function 声明的变量，在环境中「创建」这些变量。&lt;/li&gt;
&lt;li&gt;将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。&lt;/li&gt;
&lt;li&gt;开始执行代码 fn2()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」。&lt;/p&gt;

&lt;h3 id=&#34;接下来看-let-声明的-创建-初始化和赋值-过程&#34;&gt;接下来看 let 声明的「创建、初始化和赋值」过程&lt;/h3&gt;

&lt;p&gt;假设代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  let x = 1
  x = 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只看 {} 里面的过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找到所有用 let 声明的变量，在环境中「创建」这些变量&lt;/li&gt;
&lt;li&gt;开始执行代码（注意现在还没有初始化）&lt;/li&gt;
&lt;li&gt;执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）&lt;/li&gt;
&lt;li&gt;执行 x = 2，对 x 进行「赋值」&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就解释了为什么在 let x 之前使用 x 会报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = &#39;global&#39;
{
  console.log(x) // Uncaught ReferenceError: x is not defined
  let x = 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因有两个&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;console.log(x) 中的 x 指的是下面的 x，而不是全局的 x&lt;/li&gt;
&lt;li&gt;执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看到这里，你应该明白了 let 到底有没有提升：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;let 的「创建」过程被提升了，但是初始化没有提升。&lt;/li&gt;
&lt;li&gt;var 的「创建」和「初始化」都被提升了。&lt;/li&gt;
&lt;li&gt;function 的「创建」「初始化」和「赋值」都被提升了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后看 const，其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程。&lt;/p&gt;

&lt;p&gt;这四种声明，用下图就可以快速理解：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所谓暂时死区，就是&lt;strong&gt;不能在初始化之前，使用变量&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;完了吗&#34;&gt;完了吗？&lt;/h2&gt;

&lt;p&gt;故事依然没有结束，这周我在知乎上&lt;a href=&#34;https://www.zhihu.com/question/62966713&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;问了一个问题&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如何理解 let x = x 报错之后，再次 let x 依然会报错？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个问题是饥人谷的学生问我的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/let-in-js/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个问题说明：如果 let x 的初始化过程失败了，那么&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;x 变量就将永远处于 created 状态。&lt;/li&gt;
&lt;li&gt;你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。&lt;/li&gt;
&lt;li&gt;由于 x 无法被初始化，所以 x 永远处在暂时死区（也就是盗梦空间里的 limbo）！&lt;/li&gt;
&lt;li&gt;有人会觉得 JS 坑，怎么能出现这种情况；其实问题不大，因为此时代码已经报错了，后面的代码想执行也没机会。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;细节参见我的另一篇文章《&lt;a href=&#34;https://zhuanlan.zhihu.com/p/28117094&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS变量封禁大法：薛定谔的X&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;以上，就是一个 let 引发的思考。&lt;/p&gt;

&lt;p&gt;重要参考：&lt;a href=&#34;https://dmitripavlutin.com/variables-lifecycle-and-why-let-is-not-hoisted/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JavaScript variables lifecycle: why let is not hoisted&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>深入理解 CSS：字体度量、line-height 和 vertical-align</title>
      <link>http://fangyinghang.com/everything-about-font-size/</link>
      <pubDate>Thu, 16 Mar 2017 01:51:37 +0800</pubDate>
      
      <guid>http://fangyinghang.com/everything-about-font-size/</guid>
      <description>

&lt;p&gt;这是一篇译文，对 inline 和 inline-block 的元素剖析非常给力。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&#34;http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Deep dive CSS: font metrics, line-height and vertical-align - Vincent De Oliveira&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;line-height 和 vertical-align 都是简单的 CSS 属性，以致于大多数人自以为知道这两个属性的工作原理。但实际上这两个属性非常复杂，也许算得上是 CSS 里最难的两个属性，因为这两个属性和 CSS 里一个鲜为人知的特性息息相关：内联格式化上下文（IFC）（译者注：和 BFC 相对应）。&lt;/p&gt;

&lt;p&gt;举例来说，line-height 的值可以是一个长度（length）或者是一个数字，它的默认值是 normal。那么，normal 是什么呢？我们经常将 normal 理解为 1，或者 1.2，甚至连 CSS 规格文档都&lt;a href=&#34;https://www.w3.org/TR/CSS2/visudet.html#propdef-line-height&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;没有提到这一问题&lt;/a&gt;。我们知道 line-height 的值为数字时，表示的相对于 font-size 的倍数，但问题在于，font-size:100px 对应的文字在不同字体里的高度是不一样的！那么 line-height 会随着文字大小的改变而改变吗？ normal 真的表示 1 或者 1.2 吗？vertical-align 又是如何被 line-height 影响的呢？&lt;/p&gt;

&lt;p&gt;让我们来深入理解一个不那么简单的 CSS 机制。&lt;/p&gt;

&lt;h2 id=&#34;font-size&#34;&gt;font-size&lt;/h2&gt;

&lt;p&gt;下面是一段简单的 HTML 代码，一个 p 标签包含了 3 个 span 标签，每个 span 各自有一个 font-family：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    &amp;lt;span class=&amp;quot;a&amp;quot;&amp;gt;Ba&amp;lt;/span&amp;gt;
    &amp;lt;span class=&amp;quot;b&amp;quot;&amp;gt;Ba&amp;lt;/span&amp;gt;
    &amp;lt;span class=&amp;quot;c&amp;quot;&amp;gt;Ba&amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;


p  { font-size: 100px }
.a { font-family: Helvetica }
.b { font-family: Gruppo    }
.c { font-family: Catamaran }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（译者注：这几款字体你的电脑上可能没有）&lt;/p&gt;

&lt;p&gt;font-size 相同，font-family 不同，得到的 span 元素的高度也不同：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为什么 font-size: 100px 不能得到相同高度的元素呢？我测量了一下每个 span 的高度：Helvetica 115px，Gruppo 97px，Catamaran 164px。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;乍看很奇怪，但是仔细想想，这么做又是很有道理的。原因在于字体本身，这是字体的原理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一款字体会定义一个 &lt;a href=&#34;http://designwithfontforge.com/zh-CN/The_EM_Square.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;em-square&lt;/a&gt;，它是用来盛放字符的金属容器。这个 em-square 一般被设定为宽高均为 1000 相对单位，不过也可以是 1024、2048 相对单位。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字体度量都是基于这个相对单位设置的，包括 ascender、descender、capital height、x-height 等。注意这里面的值是允许相对于 em-square 出血（bleed outside）的（译者注：大概可以理解为超出 em-square）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在浏览器中，上面的 1000 相对单位会按照你需要的 font-size 缩放。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们把 Catamaran 字体放到 &lt;a href=&#34;https://fontforge.github.io/en-US/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;FontForge&lt;/a&gt; 中，分析它的字体度量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;em-square 是 1000&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ascender 是 1100，descender 是 540。通过测试发现，macOS 上的浏览器使用了 HHead Ascent 和 HHead Descent 值，Windows 上的浏览器使用了 Win Ascent 和 Win Descent（而且两个平台上的值不一样）。我们还看到 Capital Height 是 680，X height 是 485。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这意味着 Catamaran 字体占据了 1100 + 540 个相对单位，尽管它的 em-square 只有 1000 个相对单位，所以当我们设置 font-size:100px 时，这个字体里的文字高度是 164px。&lt;strong&gt;这个计算出来的高度决定了 HTML 元素的 content-area（内容区域）&lt;/strong&gt;，后面我会讲到 content-area。你可以认为 content-area 就是 background 作用的区域。&lt;/p&gt;

&lt;p&gt;我们还能看出大写字母的高度是 68px，小写字母的高度（x-height）是 49px。所以 1ex = 49px，1em = 100px，而不是 164px。（真好，em 是基于 font-size，而不是基于计算出来的高度）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在继续深入之前，说点相关的知识。当 p 元素出现在屏幕上时，它可能包含了多行内容，每行内容由多个内联元素组成（内联标签或者是包含文本的匿名内联元素），每一行都叫做一个 line-box。&lt;strong&gt;line-box 的高度是由它所有子元素的高度计算得出的&lt;/strong&gt;。浏览器会计算这一行里每个子元素的高度，再得出 line-box 的高度（具体来说就是从子元素的最高点到最低点的高度），所以默认情况下，一个 line-box 总是有足够的高度来容纳它的子元素。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;每个 HTML 元素实际上都是由多个 line-box 的容器，如果你知道每个 line-box 的高度，那么你就知道了整个元素的高度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果我们修改一下最初的 HTML 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    Good design will be better.
    &amp;lt;span class=&amp;quot;a&amp;quot;&amp;gt;Ba&amp;lt;/span&amp;gt;
    &amp;lt;span class=&amp;quot;b&amp;quot;&amp;gt;Ba&amp;lt;/span&amp;gt;
    &amp;lt;span class=&amp;quot;c&amp;quot;&amp;gt;Ba&amp;lt;/span&amp;gt;
    We get to make a consequence.
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么就会得到 3 个 line-box（宽度固定）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一行和最后一行各有一个匿名内联元素（文本内容）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;中间一行包含两个匿名内联元素和三个 span&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/7.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们清楚地看到第二个 line-box 比其他两个要高一些。因为第二行里面的子元素因为有一个用到了 Catamaran 字体的 span。&lt;/p&gt;

&lt;p&gt;line-box 的难点在于我们看不见它，而且不能用 CSS 控制它。即使我们用 ::first-line 给第一行加上背景色，我们也看不出第一个 line-box 的高度。&lt;/p&gt;

&lt;h1 id=&#34;line-height&#34;&gt;line-height&lt;/h1&gt;

&lt;p&gt;目前我已经提到了两个概念：content-area 和 line-box。如果你仔细看了，会发现我说 line-box 的高度是根据子元素的高度计算出来的，而不是子元素的 content-area 的高度。这个区别大了。&lt;/p&gt;

&lt;p&gt;接下来说句听起来很奇怪的话：一个内联元素有两个高度：content-area 高度和 virtual-area （实际区域？）高度（virtual-area 是我自己发明的单词，它表示对人类有效的高度，你在其他地方是看不到这个单词的）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;content-area 的高度是由字体度量定义的（见上文）&lt;/li&gt;
&lt;li&gt;vitual-area 的高度就是 line-height，这个高度用于计算 line-box 的高度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/8.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这么一来，这就打破了一个长久的谣言：line-height 表示两个 baseline 之间的距离。在 CSS 里，不是这样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;virtual-area 和 content-area 高度的差异叫做 leading。leading 的一半会被加到 content-area 顶部，另一半会被加到底部。因此 content-area 总是处于 virtual-area 的中间。&lt;/p&gt;

&lt;p&gt;计算出来的 line-height（也就是 virtual-area 的高度）可以等于、大于或小于 content-area。如果 virtual-area 小于 content-area，那么 leading 就是负的，因此 line-box 看起来就比内容还矮了。&lt;/p&gt;

&lt;p&gt;还有一些其他种类的内联元素：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可替换的内联元素，如 img / input / svg 等&lt;/li&gt;
&lt;li&gt;inline-block 元素，以及所有 display 值以 inline- 开头的元素，如 inline-table / inline-flex&lt;/li&gt;
&lt;li&gt;处于某种特殊格式化上下文的内联元素，例如 flexbox 元素中的子元素都处于 &lt;a href=&#34;http://link.zhihu.com/?target=https%3A//www.w3.org/TR/css-flexbox-1/%23flex-items&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;flex formatting context（弹性格式化上下文）&lt;/a&gt;中，这些子元素的 display 值都是「blockified」&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这类内联元素，其高度是基于 height、margin 和 border 属性（译者注：好像漏了 padding）。如果你将其 height 设置为 auto 的话，那么其高度的取值就是 line-height，其 content-area 的取值也是 line-height。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/10.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们目前依然没有解释 line-height:normal 是什么意思。要解答这个问题，我们又得回到 content-area 高度的计算了，问题的答案就在字体度量里面。&lt;/p&gt;

&lt;p&gt;我们回到 FontForge，Catamaran 的 em-square 高度是 1000，同时我们还看到很多其他的 ascender/descender 值：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;常规的 Ascent/Descent：ascender 是 770，descender 是 230，用于渲染字符。&lt;/li&gt;
&lt;li&gt;规格 Ascent/Descent：ascender 是 1100，descender 是 540。用于计算 content-area 的高度&lt;/li&gt;
&lt;li&gt;规格 Line Gap：用于计算 line-height: normal。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 Catamaran 这款字体中，Line Gap 的值是 0，那么 line-height: normal 的结果就跟 content-area 的高度一样，是 1640 相对单位。&lt;/p&gt;

&lt;p&gt;为了对比，我们再看看 Arial 字体，它的 em-square 是 2048，ascender 是 1854，descender 是 434，line gap 是 67。那么当 font-size: 100px 时，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;其 content-area 的高度就是 &lt;sup&gt;100&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2048&lt;/sub&gt;*(1854+434) = 111.72，约为 112px；&lt;/li&gt;
&lt;li&gt;其 line-height: normal 的结果就是 &lt;sup&gt;100&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2048&lt;/sub&gt;*(67+1854+434) 约为 115px。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有这些值都是由字体设计师设置的。&lt;/p&gt;

&lt;p&gt;这么看来，line-height:1 就是一个很糟糕的实践。记得吗，当 line-height 的值是一个数字时，其实就是相对 font-size 的倍数，而不是相对于 content-area。所以 line-height:1 很有可能使得 virtual-area 比 content-area 矮，从而引发很多其他的问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/12.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不仅仅是 line-height:1 有问题，我电脑上的 1117 款字体中，大概有 1059 款字体的 line-height 比 1 大，最低的是 0.618，最高的是 3.378。你没看错，是 3.378！&lt;/p&gt;

&lt;p&gt;line-box 计算的一些细节：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于内联元素，padding 和 border 会增大 background 区域，但是不会增大 content-area（不是 line-box 的高度）。一般来说你无法再屏幕上看到 content-area。margin-top 和 margin-bottom 对两者都没有影响。&lt;/li&gt;
&lt;li&gt;对于可替换内联元素（replaced inline elements）、inline-block 元素和 blockified 内联元素，padding、margin 和 border 会增大 height（译者注：注意 margin），因此会影响 content-area 和 line-box 的高度&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;vertical-align&#34;&gt;vertical-align&lt;/h1&gt;

&lt;p&gt;我还没提过 vertical-align 属性，它也是计算 line-box 高度的重要因素之一。我们甚至可以说 vertical-align 是内联格式化上下文（IFC）中最重要的属性。&lt;/p&gt;

&lt;p&gt;它的默认值是 baseline。还记得字体度量里的 ascender 和 descender 吗？这两个值决定了 baseline 的位置。很少有&lt;/p&gt;

&lt;p&gt;字体的 ascender 和 descender 的比例是一比一的，所以我们经常看到一些意想不到的现象，下面是例子。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    &amp;lt;span&amp;gt;Ba&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;Ba&amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;



p {
    font-family: Catamaran;
    font-size: 100px;
    line-height: 200px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个 p 标签内有两个 span 标签，span 继承了 font-family、font-size 和 200px 的 line-height。这时两个 span 的 baseline 是等高的，line-box 的高度就是 span 的 line-height。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/13.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果第二个 span 的 font-size 变小了呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;span:last-child {
    font-size: 50px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们会发现一个非常奇怪的现象，line-box 的高度变高了！如下图所示。提示你一下，line-box 的高度是从子元素的最高点到最低点的举例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/14.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个例子可以作为「&lt;a href=&#34;http://allthingssmitty.com/2017/01/30/nope-nope-nope-line-height-is-unitless/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;应该将 line-height 的值写成数字&lt;/a&gt;」的论据，但是有时候我们为了做出好看的排版，必须把 line-height 写成一个固定值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不过我实话告诉你吧，不管你把 line-height 写成什么，你都会在对齐内联元素的时候遇到麻烦。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们来看另一个例子。p 标签有 line-height:200px，内含一个 span，span 继承了 p 的 line-height。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    &amp;lt;span&amp;gt;Ba&amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;



p {
    line-height: 200px;
}
span {
    font-family: Catamaran;
    font-size: 100px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时 line-box 的高度是多少？貌似是 200px，但其实不是。这里你没有考虑到的问题是 p 有自己的 font-family，默认值是 serif。p 的 baseline 和 span 的 baseline 位置不一样，因此最终的 line-box 比我们预想的要高一些。出现这种问题是因为浏览器认为每个 line-box 的起始位置都有一个宽度为 0 的字符（CSS 文档将其称为 strut），并将其纳入 line-box 的高度的计算中。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;看不见的字符，看得见的影响。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了说明这个问题，我们画图解释一下这个问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用 baseline 来对齐令人费解，如果我们用 vertical-align: middle 会不会好一点呢？读 CSS 文档你会发现，middle 的意思是「用父元素 baseline 高度加上父元素中 x-height 的一半的高度来对齐当前元素的垂直方向的中点」。baseline 所处的高度跟字体有关，x-height 的高度也跟字体有关，所以 middle 对齐也不靠谱。更糟糕的是，一般来说，middle 根本就不是居中对齐！内联元素的对齐受太多因素影响，因此不可能用 CSS 实现。&lt;/p&gt;

&lt;p&gt;顺便一说，vertical-align 的其他 4 个值有可能有点用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vertical-align: top / bottom，表示与 line-box 的顶部或底部对齐&lt;/li&gt;
&lt;li&gt;vertical-align: text-top / text-bottom，表示与 content-area 的顶部或底部对齐&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/16.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不过你依然要小心，大部分情况下，对齐的是 virtual-area，也就是一个不可见的高度。看看下面这个用 vertical-align:top 的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/17.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后，vertical-align 的值也可以是数字，表示根据 baseline 升高或降低，不到万不得已还是别用数字吧。&lt;/p&gt;

&lt;h1 id=&#34;css-is-awesome&#34;&gt;CSS is awesome&lt;/h1&gt;

&lt;p&gt;我们讨论了 line-height 和 vertical-align 如果互相影响，现在问题来了：CSS 可以控制字体度量吗？简单来说答案是：不行。我也很想用 CSS 来控制字体。无论怎样，我还是想试试。字体度量只是一些固定的值而已，我们应该可以围绕它做点什么。&lt;/p&gt;

&lt;p&gt;比如说，我们想要一段文字使用 Catamaran 字体，同时大写字母的高度正好是 100px，看起来可以实现，我们只需要一些数学知识。&lt;/p&gt;

&lt;p&gt;首先我们把所有字体度量设置为 CSS 自定义属性，然后计算出一个 font-size，让大写字母的高度正好是 100px。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p {
    /* font metrics */
    --font: Catamaran;
    --fm-capitalHeight: 0.68;
    --fm-descender: 0.54;
    --fm-ascender: 1.1;
    --fm-linegap: 0;

    /* desired font-size for capital height */
    --capital-height: 100;

    /* apply font-family */
    font-family: var(--font);

    /* compute font-size to get capital height equal desired font-size */
    --computedFontSize: (var(--capital-height) / var(--fm-capitalHeight));
    font-size: calc(var(--computedFontSize) * 1px);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/18.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看起来也并不复杂不是吗？如果我们想要文字垂直居中怎么办呢？也就是让 B 上面的空间和下面的空间高度一样。为了做到这一点，我们必须要根据 ascender 和 descender 的比例来计算 vertical-align。&lt;/p&gt;

&lt;p&gt;首先计算出 line-height:normal 的值和 content-area 的高度：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p {
    …
    --lineheightNormal: (var(--fm-ascender) + var(--fm-descender) + var(--fm-linegap));
    --contentArea: (var(--lineheightNormal) * var(--computedFontSize));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们需要计算：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;B 下面空间的高度&lt;/li&gt;
&lt;li&gt;B 上面空间的高度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p {
    …
    --distanceBottom: (var(--fm-descender));
    --distanceTop: (var(--fm-ascender) - var(--fm-capitalHeight));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们就可以计算 vertical-align 的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p {
    …
    --valign: ((var(--distanceBottom) - var(--distanceTop)) * var(--computedFontSize));
}
span {
    vertical-align: calc(var(--valign) * -1px);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，设置 line-height：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p {
    …
    /* desired line-height */
    --line-height: 3;
    line-height: calc(((var(--line-height) * var(--capital-height)) - var(--valign)) * 1px);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/19.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;添加一个和 B 一样高的 icon 就很容易了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;span::before {
    content: &#39;&#39;;
    display: inline-block;
    width: calc(1px * var(--capital-height));
    height: calc(1px * var(--capital-height));
    margin-right: 10px;
    background: url(&#39;https://cdn.pbrd.co/images/yBAKn5bbv.png&#39;);
    background-size: cover;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/font-size/20.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jsbin.com/tufatir/edit?css,output&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JSBin 效果演示&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意这只是为了演示，请不要在生产环境中使用此方案。&lt;/p&gt;

&lt;h1 id=&#34;结论&#34;&gt;结论&lt;/h1&gt;

&lt;p&gt;我们知道了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IFC 真的很难懂&lt;/li&gt;
&lt;li&gt;所有的内联元素都有两个高度

&lt;ul&gt;
&lt;li&gt;基于字体度量的 content-area&lt;/li&gt;
&lt;li&gt;virtual-area（也就是 line-height ）&lt;/li&gt;
&lt;li&gt;这两个高度你都无法看到&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;line-height: normal 是基于字体度量计算出来的&lt;/li&gt;
&lt;li&gt;line-height: n (n=1,2,3…) 可能得出一个比 virtual-area 还要矮的 content-area&lt;/li&gt;
&lt;li&gt;vertical-align 不靠谱&lt;/li&gt;
&lt;li&gt;line-box 的高度的受其子元素的 line-height 和 vertical-align 的影响&lt;/li&gt;
&lt;li&gt;我们无法轻易的用 CSS 来控制字体度量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是我依然喜欢 CSS ：）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JS 的 new 到底是干什么的？</title>
      <link>http://fangyinghang.com/new-in-js/</link>
      <pubDate>Mon, 12 Dec 2016 01:45:22 +0800</pubDate>
      
      <guid>http://fangyinghang.com/new-in-js/</guid>
      <description>

&lt;p&gt;大部分讲 new 的文章会从面向对象的思路讲起，但是我始终认为，在解释一个事物的时候，不应该引入另一个更复杂的事物。&lt;/p&gt;

&lt;p&gt;今天我从「省代码」的角度来讲 new。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;想象我们在制作一个策略类战争游戏，玩家可以操作一堆士兵攻击敌方。&lt;/p&gt;

&lt;p&gt;我们着重来研究一下这个游戏里面的「制造士兵」环节。&lt;/p&gt;

&lt;p&gt;一个士兵的在计算机里就是一堆属性，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/new-in-js/1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们只需要这样就可以制造一个士兵：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var 士兵 = {
  ID: 1, // 用于区分每个士兵
  兵种:&amp;quot;美国大兵&amp;quot;,
  攻击力:5,
  生命值:42, 
  行走:function(){ /*走俩步的代码*/},
  奔跑:function(){ /*狂奔的代码*/  },
  死亡:function(){ /*Go die*/    },
  攻击:function(){ /*糊他熊脸*/   },
  防御:function(){ /*护脸*/       }
}

兵营.制造(士兵)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;制造一百个士兵&#34;&gt;制造一百个士兵&lt;/h2&gt;

&lt;p&gt;如果需要制造 100 个士兵怎么办呢？&lt;/p&gt;

&lt;p&gt;循环 100 次吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var 士兵们 = []
var 士兵
for(var i=0; i&amp;lt;100; i++){
  士兵 = {
    ID: i, // ID 不能重复
    兵种:&amp;quot;美国大兵&amp;quot;,
    攻击力:5,
    生命值:42, 
    行走:function(){ /*走俩步的代码*/}，
    奔跑:function(){ /*狂奔的代码*/  },
    死亡:function(){ /*Go die*/    },
    攻击:function(){ /*糊他熊脸*/   },
    防御:function(){ /*护脸*/       }
  }
  士兵们.push(士兵)
}

兵营.批量制造(士兵们)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;哎呀好简单。&lt;/p&gt;

&lt;h2 id=&#34;质疑&#34;&gt;质疑&lt;/h2&gt;

&lt;p&gt;上面的代码存在一个问题：浪费了很多内存。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;行走、奔跑、死亡、攻击、防御这五个动作对于每个士兵其实是一样的，只需要各自引用同一个函数就可以了，没必要重复创建 100 个行走、100个奔跑……&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这些士兵的兵种和攻击力都是一样的，没必要创建 100 次。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;只有 ID 和生命值需要创建 100 次，因为每个士兵有自己的 ID 和生命值。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;改进&#34;&gt;改进&lt;/h2&gt;

&lt;p&gt;看过我们的专栏以前文章（&lt;a href=&#34;https://zhuanlan.zhihu.com/p/23090041?refer=study-fe&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS 原型链&lt;/a&gt;）的同学肯定知道，用原型链可以解决重复创建的问题：我们先创建一个「士兵原型」，然后让「士兵」的 &lt;strong&gt;proto&lt;/strong&gt; 指向「士兵原型」&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var 士兵原型 = {
  兵种:&amp;quot;美国大兵&amp;quot;,
  攻击力:5,
  行走:function(){ /*走俩步的代码*/}，
  奔跑:function(){ /*狂奔的代码*/  },
  死亡:function(){ /*Go die*/    },
  攻击:function(){ /*糊他熊脸*/   },
  防御:function(){ /*护脸*/       }
}
var 士兵们 = []
var 士兵
for(var i=0; i&amp;lt;100; i++){
  士兵 = {
    ID: i, // ID 不能重复
    生命值:42
  }

  /*实际工作中不要这样写，因为 __proto__ 不是标准属性*/
  士兵.__proto__ = 士兵原型 

  士兵们.push(士兵)
}

兵营.批量制造(士兵们)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;优雅&#34;&gt;优雅？&lt;/h2&gt;

&lt;p&gt;有人指出创建一个士兵的代码分散在两个地方很不优雅，于是我们用一个函数把这两部分联系起来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function 士兵(ID){
  var 临时对象 = {}

  临时对象.__proto__ = 士兵.原型

  临时对象.ID = ID
  临时对象.生命值 = 42

  return 临时对象
}

士兵.原型 = {
  兵种:&amp;quot;美国大兵&amp;quot;,
  攻击力:5,
  行走:function(){ /*走俩步的代码*/}，
  奔跑:function(){ /*狂奔的代码*/  },
  死亡:function(){ /*Go die*/    },
  攻击:function(){ /*糊他熊脸*/   },
  防御:function(){ /*护脸*/       }
}

// 保存为文件：士兵.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以愉快地引用「士兵」来创建士兵了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var 士兵们 = []
for(var i=0; i&amp;lt;100; i++){
  士兵们.push(士兵(i))
}

兵营.批量制造(士兵们)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;js-之父的关怀&#34;&gt;JS 之父的关怀&lt;/h2&gt;

&lt;p&gt;JS 之父创建了 new 关键字，可以让我们少写几行代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/new-in-js/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;只要你在士兵前面使用 new 关键字，那么可以少做四件事情：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不用创建临时对象，因为 new 会帮你做（&lt;strong&gt;你使用「this」就可以访问到临时对象&lt;/strong&gt;）；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不用 return 临时对象，因为 new 会帮你做；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要给原型想名字了，因为 new 指定名字为 prototype。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;这一次我们用-new-来写&#34;&gt;这一次我们用 new 来写&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function 士兵(ID){
  this.ID = ID
  this.生命值 = 42
}

士兵.prototype = {
  兵种:&amp;quot;美国大兵&amp;quot;,
  攻击力:5,
  行走:function(){ /*走俩步的代码*/},
  奔跑:function(){ /*狂奔的代码*/  },
  死亡:function(){ /*Go die*/    },
  攻击:function(){ /*糊他熊脸*/   },
  防御:function(){ /*护脸*/       }
}

// 保存为文件：士兵.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是创建士兵（加了一个 new 关键字）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var 士兵们 = []
for(var i=0; i&amp;lt;100; i++){
  士兵们.push(new 士兵(i))
}

兵营.批量制造(士兵们)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;new 的作用，就是省那么几行代码。（也就是所谓的语法糖）&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;注意-constructor-属性&#34;&gt;注意 constructor 属性&lt;/h2&gt;

&lt;p&gt;new 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「士兵.prototype」加了一个 constructor 属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;士兵.prototype = {
  constructor: 士兵
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你重新对「士兵.prototype」赋值，那么这个 constructor 属性就没了，所以你应该这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;士兵.prototype.兵种 = &amp;quot;美国大兵&amp;quot;
士兵.prototype.攻击力 = 5
士兵.prototype.行走 = function(){ /*走俩步的代码*/}
士兵.prototype.奔跑 = function(){ /*狂奔的代码*/  }
士兵.prototype.死亡 = function(){ /*Go die*/    }
士兵.prototype.攻击 = function(){ /*糊他熊脸*/   }
士兵.prototype.防御 = function(){ /*护脸*/       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者你也可以自己给 constructor 重新赋值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;士兵.prototype = {
  constructor: 士兵,
  兵种:&amp;quot;美国大兵&amp;quot;,
  攻击力:5,
  行走:function(){ /*走俩步的代码*/},
  奔跑:function(){ /*狂奔的代码*/  },
  死亡:function(){ /*Go die*/    },
  攻击:function(){ /*糊他熊脸*/   },
  防御:function(){ /*护脸*/       }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>从培训班出来之后找工作的经历，教会了我这五件事</title>
      <link>http://fangyinghang.com/five-key-learnings-from-the-post-bootcamp-job-search/</link>
      <pubDate>Sat, 03 Dec 2016 01:25:35 +0800</pubDate>
      
      <guid>http://fangyinghang.com/five-key-learnings-from-the-post-bootcamp-job-search/</guid>
      <description>

&lt;p&gt;这是 &lt;a href=&#34;https://medium.freecodecamp.com/5-key-learnings-from-the-post-bootcamp-job-search-9a07468d2331&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Medium 上的一篇文章&lt;/a&gt;（已有 5900 个赞），讲的是国外一个培训出来的程序员，用三个月时间，找到了一份年薪 12 万美元的工作，并从中得到的五个忠告的故事。&lt;/p&gt;

&lt;p&gt;我觉得他总结得很好，尤其是心态和方法，非常值得学习。对正在找工作的同学非常有用。&lt;/p&gt;

&lt;p&gt;译文开始。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我们很少讨论，一个参加编程培训的人在毕业之后都会经历些什么，也就是他找工作的经历。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/five-key/1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我在 2016 年的 7 月完成了 Hack Reactor（一个编程培训网站，有线下课程，也有线上课程）的课程，之后用了三个月的时间才拿到 R 公司的 Offer。我一共向 291 个公司投递了简历，接到了 32 个电话面试，16 次技术面试，13 次代码面试，11次现场面试，最终得到 8 个 Offer。薪水范围从 60k 到 125k 美元不等（年薪），公司遍布美国各个州，既有前端职位又有全栈职位。整体来看，我的命中率是 2.8%。&lt;/p&gt;

&lt;p&gt;如果我开始找工作前知道这五个忠告，也许我会更顺利。&lt;/p&gt;

&lt;h2 id=&#34;忠告一-接触真人&#34;&gt;忠告一：接触真人&lt;/h2&gt;

&lt;p&gt;起初我找工作用的是「广撒网」的方式。我在很多网站上投简历，比如 Indeed、AngelList、LinkedIn、StackOverflow、Hacker News。我甚至到 Craigslist（相当于 58 同城）上投简历了。&lt;/p&gt;

&lt;p&gt;只要一个职位涉及 React、Node 或者 JS，我就投简历。所以最开始的一周里，我每天要投 15 到 20 封简历。&lt;/p&gt;

&lt;p&gt;结果可想而知，不到 5% 的公司回复我。我的简历石沉大海。&lt;/p&gt;

&lt;p&gt;直到有一天，我的室友，以前做过招聘，他给我分享了一个小技巧。他让我把简历直接发到那个公司员工的邮箱里，不管这个人是什么身份，只要这个人会去读邮件就行。&lt;/p&gt;

&lt;p&gt;从那之后，无论我投哪家公司，都会去 LinkedIn（译注：你可以也去微博搜）搜这家公司的开发人员或者 HR，把简历直接发送给那个人。&lt;/p&gt;

&lt;p&gt;大部分小公司的邮箱格式是「姓名全拼@公司名.com」，对于大公司格式可能就是「花名.姓名@公司名.com」。我还用到了 &lt;a href=&#34;http://link.zhihu.com/?target=https%3A//rapportive.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Rapportive&lt;/a&gt; 来保证邮箱地址的准确性。&lt;/p&gt;

&lt;p&gt;结果很喜人，我发了 150 多封邮件，居然有三十多封回信。&lt;/p&gt;

&lt;p&gt;而且他们给我的建议也很受用。我发现有些公司的 CEO 或者 CTO 会直接回复我，甚至直接面试我。&lt;/p&gt;

&lt;h2 id=&#34;忠告二-由小到大-先易后难&#34;&gt;忠告二：由小到大，先易后难&lt;/h2&gt;

&lt;p&gt;你可能会遇到段位为 1 的面试（比如一个非技术公司需要一个人维护下主页），面试中就问问 JS 基础知识。&lt;/p&gt;

&lt;p&gt;你也可能会遇到段位为 9 的面试（比如阿里巴巴和腾讯级别的面试），会被问到算法和数据结构的题目。&lt;/p&gt;

&lt;p&gt;我机智地把段位低的面试放到前面，难度高的面试放到后面。&lt;/p&gt;

&lt;p&gt;就这样，我一点点地增长面试经验，建立自信，并且拿到几个保底 Offer。&lt;/p&gt;

&lt;p&gt;随着面试经验的增加，我也在慢慢地「升级」。我开始能应对高段位的面试了。下面是我得到的 Offer 的统计图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/five-key/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我能回答更难的题目，我拿到更高的薪水，最终，我得到了我想要的工作。&lt;/p&gt;

&lt;h2 id=&#34;忠告三-学好基础知识-因为工作中会用到&#34;&gt;忠告三：学好基础知识，因为工作中会用到&lt;/h2&gt;

&lt;p&gt;你需要不停地学习和为面试做准备。&lt;/p&gt;

&lt;p&gt;为什么？因为如果你不能好好地回答面试官抛出的问题，你就得不到这份工作。&lt;/p&gt;

&lt;p&gt;如果面试官觉得你还没准备好，那么他就不会录用你。&lt;/p&gt;

&lt;p&gt;从 Hacker Reactor 学完之后，我知道我的弱项就是数据结构和算法。我听 &lt;a href=&#34;http://blog.triplebyte.com/bootcamps-vs-college&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;一项统计&lt;/a&gt; 说过，从培训班毕业的人，在数据结构和算法这两项上，比科班毕业生的基础要差一些。&lt;/p&gt;

&lt;p&gt;所以，我坚持每天学习和练习我的弱项。&lt;/p&gt;

&lt;p&gt;我花了几天持续地学习「排序算法」。我还花了几天着重理解计算机网络。&lt;/p&gt;

&lt;p&gt;如果我有一个概念不理解，我就花一整天来看视频教程、在 StackOverflow 上搜答案，直到我搞懂。&lt;/p&gt;

&lt;h2 id=&#34;忠告四-展现你最好的一面&#34;&gt;忠告四：展现你最好的一面&lt;/h2&gt;

&lt;p&gt;进入互联网行业并不简单。不管你有没有准备好，你都必须表现得很好。为了取胜，你必须展现出你最好的一面。&lt;/p&gt;

&lt;h3 id=&#34;推销自己&#34;&gt;推销自己&lt;/h3&gt;

&lt;p&gt;在 Hack Reactor，我们被告知不要主动说明自己没经验。在自我介绍的时候，我们也会不主动提自己在线学习的经历。&lt;/p&gt;

&lt;p&gt;为什么？因为不这样做的话，面试官会马上认为我们是初级开发者，并且给我们打上「没经验」的标签。&lt;/p&gt;

&lt;p&gt;有一次我去一家创业公司面试，当面试官知道我是从在线培训班出来的人之后，直接就走了。还有一家公司因为我的培训经历向我压价，只肯给我 60k 美元的 Offer，比普通初级开发者还低。（译注：不要以为 60k 美元很多，硅谷随便租个单间可能都要每月 1200 美元）&lt;/p&gt;

&lt;p&gt;记住，你要说服面试官你能做好这份工作。&lt;/p&gt;

&lt;p&gt;同时，你要说服你自己，你能做好这份工作。&lt;/p&gt;

&lt;p&gt;你可以跟面试官谈论你对编程的热爱，谈你用 React 和 Node 做过的项目，谈你对 JS 的深刻理解。&lt;/p&gt;

&lt;p&gt;一旦面试官知道了这些，你是不是从培训班里出来的，已经不重要了。&lt;/p&gt;

&lt;p&gt;只有这样，面试官才会录用你。&lt;/p&gt;

&lt;h3 id=&#34;双向选择&#34;&gt;双向选择&lt;/h3&gt;

&lt;p&gt;面试是应聘者和面试官互相了解的过程。&lt;/p&gt;

&lt;p&gt;你要做的就是说服面试官录用你，面试官要做的就是争取到靠谱的人。&lt;/p&gt;

&lt;p&gt;把面试当做你评估你的胜算的过程。把面试当做垫脚石不是一件可耻的事情。&lt;/p&gt;

&lt;p&gt;就算我对一个公司没兴趣，我也会去面试的。&lt;/p&gt;

&lt;p&gt;我会去全国各地面试，只要那个公司邀请我去。我会问面试官问题，从中我了解到了很多新的知识，比如技术团队的结构、他们使用了哪些技术、用到了哪些工具，遇到了哪些挑战，以及他们的系统架构。&lt;/p&gt;

&lt;p&gt;建议你在面试的时候问面试官以下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你们最近遇到了什么技术挑战？&lt;/li&gt;
&lt;li&gt;你在这个公司最满意的一点是什么？&lt;/li&gt;
&lt;li&gt;你们的团队是怎样的结构，工作是怎么分配的？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我把每次面试当做一次学习的机会。每次面试都帮助我提高我的表达能力、面试能力和技术能力。每次面试失败都让我找到我的弱项。&lt;/p&gt;

&lt;h2 id=&#34;忠告五-这是一场马拉松-不是百米赛跑&#34;&gt;忠告五：这是一场马拉松，不是百米赛跑&lt;/h2&gt;

&lt;p&gt;这三个月对我来说绝对不容易。这三个月，我每周都要辛苦六天用于找工作和学习。不过我还是把自己照顾得很好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/five-key/3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有的时候，我会和朋友一起学。有的时候，我会找个咖啡馆自己一个人学，或者去 Hack Reactor 提供的休息室学。每周我还会和教练报告我的进度。&lt;/p&gt;

&lt;p&gt;在这个过程中很容易耗尽热情。那么就吃好，睡好，继续学。&lt;/p&gt;

&lt;p&gt;而且会很容易感到孤单。和一群学友们在一起会好一点。&lt;/p&gt;

&lt;p&gt;建议：要有长期作战的心理准备，照顾好自己的身体。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;联系真人&lt;/li&gt;
&lt;li&gt;由小到大，先易后难&lt;/li&gt;
&lt;li&gt;学好基础知识，因为工作中会用到&lt;/li&gt;
&lt;li&gt;展现你最好的一面&lt;/li&gt;
&lt;li&gt;这是一场马拉松，不是百米赛跑&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你可能觉得找到好工作遥遥无期，但是你会成功的。持续地投入时间、持续地投简历、持续地照顾好自己。&lt;/p&gt;

&lt;p&gt;你会得到你应得的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>this 的值到底是什么？一次说清楚</title>
      <link>http://fangyinghang.com/this-in-js/</link>
      <pubDate>Sun, 20 Nov 2016 13:39:30 +0800</pubDate>
      
      <guid>http://fangyinghang.com/this-in-js/</guid>
      <description>

&lt;p&gt;你可能遇到过这样的 JS 面试题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
  foo: function(){
    console.log(this)
  }
}

var bar = obj.foo
obj.foo() // 打印出的 this 是 obj
bar() // 打印出的 this 是 window
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请解释最后两行函数的值为什么不一样。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;初学者关于 this 的理解一直很模糊。今天这篇文章就要一次讲清楚了。&lt;/p&gt;

&lt;p&gt;而且这个解释，你在别的地方看不到。看懂这篇文章，所有关于 this 的面试题，都是小菜。&lt;/p&gt;

&lt;h2 id=&#34;函数调用&#34;&gt;函数调用&lt;/h2&gt;

&lt;p&gt;首先需要从函数的调用开始讲起。&lt;/p&gt;

&lt;p&gt;JS（ES5）里面有三种函数调用形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func(p1, p2) 
obj.child.method(p1, p2)
func.call(context, p1, p2) // 先不讲 apply
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。&lt;/p&gt;

&lt;p&gt;从看到这篇文章起，你一定要记住，第三种调用形式，才是正常调用形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func.call(context, p1, p2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他两种都是语法糖，可以等价地变为 call 形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func(p1, p2) 等价于
func.call(undefined, p1, p2)

obj.child.method(p1, p2) 等价于
obj.child.method.call(obj.child, p1, p2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请记下来。（我们称此代码为「转换代码」，方便下文引用）&lt;/p&gt;

&lt;p&gt;至此我们的函数调用只有一种形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func.call(context, p1, p2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，this 就好解释了 this，就是上面代码中的 context。就这么简单。&lt;/p&gt;

&lt;p&gt;也就是说 &lt;strong&gt;this 是你 call 一个函数时传的第一个参数&lt;/strong&gt;，
只是由于你从来不用 call 形式的函数调用，所以你一直不知道。&lt;/p&gt;

&lt;h2 id=&#34;func-p1-p2-里的-this&#34;&gt;func(p1, p2) 里的 this&lt;/h2&gt;

&lt;p&gt;先看 func(p1, p2) 中的 this 如何确定：&lt;/p&gt;

&lt;p&gt;当你写下面代码时&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func(){
  console.log(this)
}

func()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等价于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func(){
  console.log(this)
}

func.call(undefined) // 可以简写为 func.call()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则：&lt;/p&gt;

&lt;p&gt;如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）
因此上面的打印结果是 window。&lt;/p&gt;

&lt;p&gt;如果你希望这里的 this 不是 window，很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func.call(obj) // 那么里面的 this 就是 obj 对象了
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;obj-child-method-p1-p2-里的-this&#34;&gt;obj.child.method(p1, p2) 里的 this&lt;/h2&gt;

&lt;p&gt;再看 obj.child.method(p1, p2) 的 this 如何确定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
  foo: function(){
    console.log(this)
  }
}

obj.foo() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照「转换代码」，我们将 obj.foo() 转换为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj.foo.call(obj)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，this 就是 obj。搞定。&lt;/p&gt;

&lt;p&gt;回到题目：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
  foo: function(){
    console.log(this)
  }
}

var bar = obj.foo
obj.foo() // 转换为 obj.foo.call(obj)，this 就是 obj
bar() 
// 转换为 bar.call()
// 由于没有传 context
// 所以 this 就是 undefined
// 最后浏览器给你一个默认的 this —— window 对象
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;语法&#34;&gt;[ ] 语法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function fn (){ console.log(this) }
var arr = [fn, fn2]
arr[0]() // 这里面的 this 又是什么呢？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以把 arr[0]( ) 想象为arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr[0]() 
假想为  arr.0()
然后转换为 arr.0.call(arr)
那么里面的 this 就是 arr 了 :)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;this 就是你 call 一个函数时，传入的第一个参数。（请务必背下来「this 就是 call 的第一个参数」）
如果你的函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式。&lt;/p&gt;

&lt;p&gt;以后你遇到所有跟 this 有关的笔试题，都不会有疑问了。&lt;/p&gt;

&lt;p&gt;完。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JS 中的闭包是什么？</title>
      <link>http://fangyinghang.com/closures-in-js/</link>
      <pubDate>Sun, 18 Sep 2016 01:36:43 +0800</pubDate>
      
      <guid>http://fangyinghang.com/closures-in-js/</guid>
      <description>

&lt;p&gt;大名鼎鼎的闭包！这一题终于来了，面试必问：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;请用自己的话简述&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;什么是「闭包」。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;「闭包」的作用是什么。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;首先来简述什么是闭包&#34;&gt;首先来简述什么是闭包&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/closures-in-js/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假设上面三行代码在一个立即执行函数中（为简明起见，我就不写立即执行函数了，影响读者理解）。&lt;/p&gt;

&lt;p&gt;三行代码中，有一个局部变量 local，有一个函数 foo，foo 里面可以访问到 local 变量。&lt;/p&gt;

&lt;p&gt;好了这就是一个闭包：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;就这么简单。&lt;/p&gt;

&lt;p&gt;有的同学就疑惑了，闭包这么简单么？&lt;/p&gt;

&lt;p&gt;「我听说闭包是需要函数套函数，然后 return 一个函数的呀！」&lt;/p&gt;

&lt;p&gt;比如这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(){
  var local = 1
  function bar(){
    local++
    return local
  }
  return bar
}

var func = foo()
func()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面确实有闭包，local 变量和 bar 函数就组成了一个闭包（Closure）。&lt;/p&gt;

&lt;h3 id=&#34;为什么要函数套函数呢&#34;&gt;为什么要函数套函数呢？&lt;/h3&gt;

&lt;p&gt;是因为需要局部变量，所以才把 local 放在一个函数里，如果不把 local 放在一个函数里，local 就是一个全局变量了，达不到使用闭包的目的——隐藏变量（等会会讲）。&lt;/p&gt;

&lt;p&gt;这也是为什么我上面要说「运行在一个立即执行函数中」。&lt;/p&gt;

&lt;p&gt;有些人看到「闭包」这个名字，就一定觉得要用什么包起来才行。其实这是翻译问题，闭包的原文是 Closure，跟「包」没有任何关系。&lt;/p&gt;

&lt;p&gt;所以函数套函数只是为了造出一个局部变量，跟闭包无关。&lt;/p&gt;

&lt;h3 id=&#34;为什么要-return-bar-呢&#34;&gt;为什么要 return bar 呢？&lt;/h3&gt;

&lt;p&gt;因为如果不 return，你就无法使用这个闭包。把 return bar 改成 window.bar = bar 也是一样的，只要让外面可以访问到这个 bar 函数就行了。&lt;/p&gt;

&lt;p&gt;所以 return bar 只是为了 bar 能被使用，也跟闭包无关。&lt;/p&gt;

&lt;h2 id=&#34;闭包的作用&#34;&gt;闭包的作用&lt;/h2&gt;

&lt;p&gt;闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。&lt;/p&gt;

&lt;p&gt;假设我们在做一个游戏，在写其中关于「还剩几条命」的代码。&lt;/p&gt;

&lt;p&gt;如果不用闭包，你可以直接用一个全局变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.lives = 30 // 还有三十条命
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样看起来很不妥。万一不小心把这个值改成 -1 了怎么办。所以我们不能让别人「直接访问」这个变量。怎么办呢？&lt;/p&gt;

&lt;p&gt;用局部变量。&lt;/p&gt;

&lt;p&gt;但是用局部变量别人又访问不到，怎么办呢？&lt;/p&gt;

&lt;p&gt;暴露一个访问器（函数），让别人可以「间接访问」。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;!function(){
  var lives = 50
  window.奖励一条命 = function(){
    lives += 1
  }
  window.死一条命 = function(){
    lives -= 1
  }
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简明起见，我用了中文 :)&lt;/p&gt;

&lt;p&gt;那么在其他的 JS 文件，就可以使用 window.奖励一条命() 来涨命，使用 window.死一条命() 来让角色掉一条命。&lt;/p&gt;

&lt;p&gt;看到闭包在哪了吗？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/closures-in-js/3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;闭包到底是什么&#34;&gt;闭包到底是什么？&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/closures-in-js/4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;五年前，我也被这个问题困扰，于是去搜了 stackoverflow 并总结下来。你在百度搜闭包，那篇《JavaScript闭包——懂不懂由你，反正我是懂了》就是我写的。当时我还是新手，一直不理解为什么大家口中的闭包这么模糊、这么琢磨不定呢。&lt;/p&gt;

&lt;p&gt;我们重新来审视一下闭包的代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/closures-in-js/2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一句是变量声明，第二句是函数声明，第三句是 console.log。&lt;/p&gt;

&lt;p&gt;每一句我都学过，为什么合起来我就看不出来是闭包？&lt;/p&gt;

&lt;p&gt;我告诉你答案，你根本不需要知道闭包这个概念，一样可以使用闭包！&lt;/p&gt;

&lt;p&gt;闭包是 JS 函数作用域的副产品。&lt;/p&gt;

&lt;p&gt;换句话说，正是由于 JS 的函数内部可以使用函数外部的变量，所以这段代码正好符合了闭包的定义。而不是 JS 故意要使用闭包。&lt;/p&gt;

&lt;p&gt;很多编程语言也支持闭包，另外有一些语言则不支持闭包。&lt;/p&gt;

&lt;p&gt;只要你懂了 JS 的作用域，你自然而然就懂了闭包，即使你不知道那就是闭包！&lt;/p&gt;

&lt;h2 id=&#34;所谓闭包的作用&#34;&gt;所谓闭包的作用&lt;/h2&gt;

&lt;p&gt;如果我们在写代码时，根本就不知道闭包，只是按照自己的意图写，最后，发现满足了闭包的定义。&lt;/p&gt;

&lt;p&gt;那么请问，这算是闭包的作用吗？&lt;/p&gt;

&lt;p&gt;这个问题，留给你思考。&lt;/p&gt;

&lt;h2 id=&#34;关于闭包的谣言&#34;&gt;关于闭包的谣言&lt;/h2&gt;

&lt;p&gt;闭包会造成内存泄露？&lt;/p&gt;

&lt;p&gt;错。&lt;/p&gt;

&lt;p&gt;说这话的人根本不知道什么是内存泄露。内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。&lt;/p&gt;

&lt;p&gt;闭包里面的变量明明就是我们需要的变量（lives），凭什么说是内存泄露？&lt;/p&gt;

&lt;p&gt;这个谣言是如何来的？&lt;/p&gt;

&lt;p&gt;因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。&lt;/p&gt;

&lt;p&gt;这是 IE 的问题，不是闭包的问题。参见司徒正美的&lt;a href=&#34;http://www.cnblogs.com/rubylouvre/p/3345294.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;一个小经验&#34;&gt;一个小经验&lt;/h2&gt;

&lt;p&gt;编程界崇尚以简洁优雅为美，很多时候&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你觉得一个概念很复杂，那么很可能是你理解错了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;完。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>微信订阅</title>
      <link>http://fangyinghang.com/wechat-subscribe/</link>
      <pubDate>Sun, 08 Nov 2015 03:43:41 +0800</pubDate>
      
      <guid>http://fangyinghang.com/wechat-subscribe/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://fangyinghang.com/images/me/qrcode.jpg&#34; alt=&#34;扫码关注&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>联系方式</title>
      <link>http://fangyinghang.com/contacts/</link>
      <pubDate>Sun, 08 Nov 2015 03:43:41 +0800</pubDate>
      
      <guid>http://fangyinghang.com/contacts/</guid>
      <description>&lt;p&gt;邮箱：fangyinghang # foxmail.com&lt;/p&gt;

&lt;p&gt;知乎：&lt;a href=&#34;https://www.zhihu.com/people/zhihusucks/answers/by_votes&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;zhihusucks&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
